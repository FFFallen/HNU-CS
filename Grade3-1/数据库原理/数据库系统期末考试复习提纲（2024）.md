

# 数据库系统期末考试复习提纲（2024） 

## 第一章 数据库系统概述

### 1.1 数据库的4个基本概念（数据、数据库、数据库管理系统和数据库系统）

- 数据：描述事务的==符号记录==，数据库中存储的==基本对象==

- 数据库：是==长期存储==在计算机内，==有组织==的、==可共享==的==大量数据==的集合

- 数据库管理系统：位于用户与操作系统之间的一层==数据管理软件==，是一个==大型复杂==的软件系统

- 数据库系统：在计算机系统中引入数据库后的系统构成
  - 由四个部分组成：
    - 数据库
    - 数据库管理系统
    - 应用系统
    - 数据库管理员

### 1.2数据库系统的特点  

- 数据结构化：数据用==统一的模型==进行描述
- 数据共享化：数据被==多用户、多应用、不同接口、不同编程语言==共享使用
- 数据独立性：数据与==应用程序==相分离，包括数据的==物理独立性==和数据的==逻辑独立性==
- 数据被数据库管理系统统一管理和控制：数据库管理系统在数据库建立、运维时对数据库进行统一控制

### 1.3数据模型及三要素  

数据模型是对现实世界中实体和实体之间的联系等的==抽象和表示==

三要素：

- 数据结构：描述数据的==静态特征==，即数据的组织方式和逻辑关系
  - 数据的组成：基本单位（如记录、字段）
  - 数据之间的关系：一对一、一对多、多对多的逻辑关联
- 数据操作：描述数据的==动态特性==，即如何对数据进行操作和处理
  - 查询、删除、更新和插入
- 数据约束：描述数据的==完整性和一致性==规则
  - 实体完整性
  - 参照完整性
  - 用户定义的完整性

### 1.4数据库系统的三级模式结构（外模式、模式、内模式）

- 模式（逻辑模式）
  - 数据库中==全体数据==的==逻辑结构==和==特征==的描述
  - 所有用户的公共数据视图
- 外模式（子模式、用户模式）
  - 数据库用户使用的==局部数据==逻辑结构和特征描述
  - 数据库用户的数据视图，是==与某一应用有关==的数据的逻辑表示
- 内模式（存储结构）
  - 是数据的==物理结构==和==存储方式==的描述
  - 数据在数据库的内部的表示方式

数据库的二级映像功能与数据独立性（逻辑独立性、物理独立性）

-   外模式/模式的映像：每一个外模式，数据库都有一个模式/外模式映像，==定义外模式和模式之间的对应关系==
  - 保证数据的逻辑独立性
  - 当模式改变时，数据库管理员只需要对外模式/模式映像作相应改变，外模式保持不变，应用程序是根据外模式编写的，应用程序也不必修改保证了数据的逻辑独立性
- 模式/内模式映像：定义了数据==全局逻辑结构与存储方式==之间的对应关系，例如说明数据的逻辑记录和字段是如何在内部表示的
  - 保证数据的物理独立性
  - 当数据的存储方式改变了，数据库管理员修改模式/内模式映像，使模式保持不变，应用程序不受影响，保证了数据的物理独立性

## 第二章 关系模型

### 2.1 关系模型的数据结构--关系

现实世界的实体与实体之间的各种联系均用关系来表示

关系也是一个==二维表==，表的每行对应一个元组，表的每列对应一个域

三类关系：

- 基本关系：实际存在的表，是实际存储数据的逻辑表示
- 查询表：查询结果对应的表
- 视图表：由==基本表或其他视图表==导出的表，是虚表，不对应实际存储的数据

### 2.2 关系模式、候选码、主码（主键）、主属性、非主属性、外码

- 关系模式：对关系的描述
- 码
  - 候选码：关系模式中能==唯一标识一个元组==的一个属性或一组属性，而它的真子集不能唯一标识一个元组
  - 全码：关系模式中==所有的属性组==是这个关系模式的候选码，称为全码
  - 主码（主键）：若一个关系模式中有多个候选码，则==选择其中一个==作为主码
  - 主属性：==候选码中的诸属性==称为主属性
  - 非主属性：==不包含在候选码==中的属性
  - 外码：

### 2.3 关系代数  并、差、交、笛卡尔积、选择、投影、连接、除运算。

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询

集合运算：

- 并：$R \cup S$，属于R或属于S的元组组成的关系
- 差：$R - S$，属于R但不属于S的元组组成的关系
- 交：$R \cap S$，属于R且属于S的元组组成的关系
- 笛卡尔积：$R \times S$， 列：(*n*+*m*)列元组的集合;行：*k*1×*k*2个元组

关系运算：

- 选择：在关系R中选择==满足给定条件==的元组，记作$\sigma_F(R) $，例$\sigma_{Category = '数码产品'}（Products）$
- 投影：关系R上的投影是从R中==选择若干属性列==组成==新的关系==，记作$∏_A(R)$，例$∏_{Cname, City}(Customers)$
  - 投影之后不仅==取消了原关系中的某些列==，而且还可能==取消某些元组==（==避免重复行==）
- 连接：从==两个关系的笛卡尔积==中选取==其属性间满足一定条件==的元组，组合成一个新的关系，记作$R \Join_{\theta} S $，例$Customer \Join_{C.CID = O.CID} Order$
  - 连接运算$R \Join_{A = B} S $是从笛卡儿积$R \times S$​中选取关系R在属性列A上的值与关系S在属性列B上的值满足==比较关系\===的元组
  - ==自然连接==是一种==特殊的等值连接==。它要求两个关系中进行比较的分量必须是同名的属性列,==等值连接会保留重复的属性列==（与自然连接的区别）,记作$R \Join S $​。
  - ==内连接==是两个关系做==自然连接==时，连接的结果是满足条件的元组保留下来，不满足条件的元组被舍弃
  - ==外连接==是把悬浮元组（自然连接时关系被舍弃掉的元组）也保存在结果关系中，而在其他属性上填空值（NULL）
- 除：设关系R除以关系S的结果为关系T，则T包含所有==在R但不在S中属性及其值==，且T的元组与S的元组的所有组合都在关系R中，记作$R \div S$
  - 使用除运算的情况：解决“查询...全部/所有的..."的问题(“全包含”的问题)，比如查询所有选修了全部课程的学生的学号：$∏_{Sno, Cno}(SC) \div ∏_{Cno}(Course)$
  - 与"查询全部/所有..."区分，比如查询所有信息系的学生：$∏_{Sno, Sname, dept}(\sigma_{dept = CS}(Student))$

### 2.4关系代数查询及关系运算

![截屏2024-12-09 下午3.53.11](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-09 下午3.53.11.png)

答案：D

![截屏2024-12-09 下午3.56.57](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-09 下午3.56.57.png)

答案：C

3、设有学生关系 S(Sno ， Sname ， Reward) ，选课关系 SC （ Sno ， Cno ， Grade ） , 课程关系 C(Cno ， Cname ， Cpo) 

试用关系代数表达式检索没有选修 Database 课程的学生姓名。
$$
∏_{Sname}(S) - ∏_{Sname}(S \Join (\sigma_{Cname = 'Database'}(SC \Join C )))
$$
试用关系代数表达式检索至少选修了一门其直接先行课为 Database 的学生姓名。 
$$
∏_{Sname}(S \Join (SC \Join ∏_{Cno}(\sigma_{Cpo = 'Database'})))
$$
或
$$
∏_{Sname}(\sigma_{Cpo = 'Database'}(C \Join SC \Join ∏_{Sname,Sno}(S)))
$$


### 2.5 关系完整性

-  实体完整性：目的是保证关系数据库中每个元组==是可区分的==，并且是==唯一==的
  - 实体完整性约束：若属性A是关系R的主属性，则A不能取==空值==
- 参照完整性：
  - 参照完整性约束：若属性（或属性组）*F*是基本关系*R*的外码它与基本关系*S*的主码Ks相对应（基本关系*R*和*S*不一定是不同的关系），则对于*R*中每个元组在*F*上的值必须为：（**相关联的两个表之间的约束**）
    - 或者取空值
    - 或者等于S中某个元组的主码值
- 用户定义的完整性：针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求
  - 用户定义的完整性约束：用户根据实际情况定义的约束，例如学生成绩取值在0-100之间

违规处理：

- 实体完整性：
  - ==拒绝执行==:不允许该操作执行
  - ==调整数据==：自动生成主码值，如通过AUTO_INCRMENT自动增长
- 参照完整性：
  - ==拒绝操作==：不允许该操作执行
  - ==级联操作==：当==删除或修改被参照表==的一个元组导致与参照表的不一致时，==删除或修改参照表==中所有导致不一致的元组
  - ==设置为空值==：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值
- 用户定义的完整性：
  - ==拒绝执行==：不允许该操作执行
  - 触发器处理：通过触发器实现更复杂的约束检查和自动处理。

## 第三章 关系数据库标准语言SQL

### 3.1 SQL的基本概念、基本表、视图。

SQL：Structure Queru Language，结构化查询语言

==SQL==是用于==管理关系型数据库==并对其中的数据进行一系列的操作（包括数据的插入、查修、修改和删除等）的一种语言

特点：

- 综合统一：集数据定义语言（DDL）、数据操纵语言（DML）、数据控制语言（DCL）功能与一体
- 高度非过程化
- 面向集合的操作方式
- 以同一种语法结构提供多种使用方式
- 语言简洁，易学易用

==基本表==是本身==独立存在==的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件

==视图==是从一个或几个基本表导出的表。它本身==不独立存储==在数据库中，即数据库==只存储视图的定义==而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。

### 3.2基本表的定义、修改与删除

#### 定义基本表

- 定义基本表

  ```sql
  CREATE TABLE <表名> (<列名> <数据类型> <列级完整性约束条件>)
  # 例：
  CREATE TABLE Student
  ( Sname VARCHAR(32) not null,	# 列级完整性约束
    Sno INT Primary key Auto_increment,	# 列级完整性约束
    Sage SAMLLINT,
    Ssex VARCHAR(4),
    Sdept VARCHAR(20),
  	# 表级完整性约束
    FOREIGN KEY (Sdept) REFERENCES DEPT(Dname) 
  );
  
  CREATE TABLE Course
  (	Cno INT,
    Cname VARCHAR(32) not null, # 列级完整性约束
   	Cpno INT,
   	Ccredit INT,
   	# 表级完整性约束
   	PRIMARY KEY (Cno),
   	FOREIGN KEY (Cpno) REFERENCES Course(Cno)
  );
  ```

#### 修改基本表

- 修改基本表

  ```sql
  ALTER TABLE <表名>
  [ADD [COLUMN] <新列名> <数据类型> [完整性约束]]
  [ADD <表级完整性约束>]
  [DROP [COLUMN] <新列名> [CASCADE | RESTRICT]]
  [DROP CONSTRAINT <完整性约束名> [CASCADE | RESTRICT]]
  [ALTER COLUMN <列名> <数据类型>];
  
  # 例
  # 增加新列
  ALTER TABLE Student 
  ADD S_entrance DATE;
  
  # 增加新完整性约束
  ALTER TABLE Course
  ADD UNIQUE (Cname)
  
  # 修改某一列的数据类型
  ALTER TABLE Student
  ALTER COLUMN Sage INT;
  
  # 删除某一列(默认选项为RESTRICT)
  ALTER TABLE Student
  DROP Sage;
  
  # 删除某一完整性约束(默认选项为RESTRICT)
  ALTER TABLE Studnet
  DROP CONSTRAINT FOREIGN_KEY_Cno;
  ```

#### 删除基本表

- 删除基本表

  ``` sql
  DROP TABLE <表名> [RESTRICT |CASCADE];
  
  # 例
  DROP TABLE Student CASCADE;
  ```

### 3.3 索引的定义、修改与删除

建立索引的目的：加快查询速度

#### 定义索引

- 定义索引

  ```sql
  CREATE [UNIQUE][CLUSTER] INDEX <索引名>
  ON <表名>(<列名> [<次序>], ..., <列名> [<次序>]);
  
  # 次序：指定索引值的排列顺序：ASC升序 DESC降序 缺省值为ASC
  # UNIQUE：此索引的每个索引值只对应唯一的数据记录
  # CLUSTER：建立的索引是聚簇索引,聚簇索引是指索引顺序与表中记录的物理顺序一致的索引
  #	在最经常查询的列表上建立聚簇索引以提高查询效率；一个基本表上最多只能建立一个聚簇索引；经常更新的列不宜建立聚簇索引。
  
  # 例：
  #为学生-课程数据库中的Student，Course，SC三个表建立索引。
  #Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引
  
  CREATE UNIQUE INDEX Sno_index
  ON Student(Sno ASC);
  
  CREATE UNIQUE INDEX Cno_index
  ON Course(Cno);
  
  CREATE UNIQUE INDEX Sno_index2
  ON SC (Sno ASC, Cno DESC);
  ```

#### 修改索引

- 修改索引

  ```sql
  ALTER INDEX <索引名> RENAME TO <新索引名>;
  
  # 例：
  #	将SC表的SCno索引名改为SCSno
  
  ALTER INDEX SCno RENAME TO SCSno;
  ```

#### 删除索引

- 删除索引

  ```sql
  DROP INDEX <索引名>;
  
  # 例：
  DROP INDEX SCSno
  ```

### ==3.4 数据查询: 常用的SQL语句，常用的查询、分组、排序等SQL 语句==

数据查询是从数据库中获取满足一定条件的数据，是数据库的==核心操作==。基本语法格式为:

```sql
SELECT [ALL | DISTINCT] <列表达式>, ..., <列表达式>
FROM <表名 / 视图名>, ..., <表名 / 视图名>
[WHERE <条件表达式>]
[GROUP BY <列名>, ..., <列名>]
[HAVING <条件表达式>]
[ORDER BY <列表达式> [<次序>], ..., <列表达式> [<次序>]];
```

> [!TIP]
>
> - GROUP BY子句：指定按照哪些列对元组进行分组
>
> - HAVING子句：对分组结果进行筛选
>
> - ORDER BY子句：将查询结果按照指定顺序进行排序

#### **查询**

- **常用的查询操作**

  ```sql
  # 投影操作：SELECT
  # 查询所有学生的学号、姓名、所在系、年龄和性别
  SELECT Sno, Sname, Sdept, Sage, Ssex
  FROM Student;
  
  SELECT *
  FROM Student;
  
  # 查询所有学生的姓名、出生年份和所在系，要求系名用小写字母表示。
  SELECT Sname, 2024-Sage, LOWER(Sdept)
  FROM Student;
  
  SELECT Sname, 2024-Sage AS Sbirth, LOWER(Sdept)	# 使用AS改变查询结果的列标题
  FROM Student;
  
  # 选择操作：WHERE
  # 查询计算机系学生的学号、姓名和年龄。
  SELECT Sno, Sname, Sage
  FROM Student
  WHERE Sdept = "CS";
  
  # 查询年龄在18岁及以上学生的学号、姓名和年龄
  SELECT Sno, Sname, Sage
  FROM Student
  WHERE Sage >= 18;
  
  # 查询分数在80到90之间的学生学号、课程号以及分数 
  SELECT Sno, Cno, Grade
  FROM SC
  WHERE Grade BETWEEN 80 AND 90;
  ```

#### 分组

- **分组操作**

  `GROUP BY`子句可以将查询到的==满足条件的元组==按照某一列或多列的值进行分组，值相等的为一组。

  任何==没有出现在GROUP BY子句==中的列如果出现在SELECT子句中的话，那么它一定是==出现在聚集函数内部==。

  ```sql
  # 例
  # 将学生选课表按照课程号列进行分组:查询各个课程的选课人数。
  SELECT Cno, COUNT(*)
  FROM SC
  GROUP BY Cno;
  
  # 查询所有选课学生的学号及平均分
  SELECT Sno, AVG(Grade)
  FROM SC
  GROUP BY Sno;
  # 查询平均分超过90的学生的学号和平均成绩。
  SELECT Sno, AVG(Grade)
  FROM SC
  GROUP BY Sno
  HAVING AVG(Grade) > 90;	#HAVING子句用来对GROUP BY后得到的组进行筛选
  
  # 查询各个系的男生和女生人数。
  SELECT Sdept,Sgender, COUNT(*)
  FROM Student
  GROUP BY Sdept, Sgender;
  ```

#### 排序

- **排序操作**

  `ORDER BY`子句将查询结果按照某一列（或多列）的值进行排序：

  ASC：升序（缺省值）	DESC降序

  ```sql
  # 例
  # 查询选修1号课程的学生学号与成绩，并将查询结果按照成绩降序排序
  SELECT Sno, Grade
  FROM SC
  WHERE Cno = "1"
  ORDER BY Grade DESC;
  
  # 查询所有选课学生的学号及平均分，并将查询结果按照平均分降序排序，平均分相同的学生按照学号升序排序。
  SELECT Sno, AVG(Grade)
  FROM SC
  GROUP BY Sno
  ORDER BY AVG(Grade) DESC, Sno ASC;
  ```

### 3.5 能熟练使用聚集函数、通配符

#### 聚集函数

- 聚集函数

  ```sql
  # 统计元组个数
  COUNT ([DISTINCT |ALL]*)
  # 例：查询学生总人数
  SELECT COUNT (*)
  FROM Student;
  
  # 统计一列值的个数
  COUNT ([DISTINCT | ALL] <列名>)
  # 例：查询选修了课程的学生人数
  SELECT COUNT (DISTINCT Sno) # 需要除去重复选课情况
  FROM SC;
  
  # 统计一列值
  SUM([DISTINCT | ALL] <列名>)
  # 例：查询所有学生的所有课程总分
  SELECT SUM(Grade)
  FROM SC;
  
  # 统计一列值的平均值
  AVG ([DISTINCT | ALL] <列名>)
  # 例：查询选修1号课程的学生的平均成绩
  SELECT AVG(Grade)
  FROM SC
  WHERE Cno = "1";
  
  # 统计一列的最大值
  MAX ([DISTINCT | ALL] <列名>)
  
  # 统计一列的最小值
  MIN ([DISTINCT | ALL] <列名>)
  
  # 当指定DISTINCT时，聚集函数要应用在消除重复取值的列上
  ```

#### 通配符

- 通配符

  LIKE可以用来查询与匹配串匹配的字符串。其语法格式为：

  ```sql
  [NOT] LIKE "<匹配串>" [ESCAPE"<换码字符>"]
  ```

  - 匹配串一般由字符和通配符组成，通配符包括_和%
  - _：匹配字符串中的任意一个字符
  - %：匹配字符串中的任意多个字符（包括0个和1个）
  - 但字符串的所有字符均可匹配成功时，该字符串的LIKE查询结果为真
  - 当匹配串中本身就包含通配符\_或%时，需要在匹配串中包含的\_或%前面加上转义字符来进行转义，同时需要使用`ESCAPE“<换码字符>”`来指定换码字符

  ```sql
  # 例：
  # 查询所有姓王的且名字包含两个字的学生的学号、姓名、性别和所在系。
  SELECT Sno, Sname, Sgender, Sdept
  FROM Student
  WHERE Sname LIKE "王_";
  
  # 查询课程名中包含“数据”的课程，输出其课程号、课程名及其学分。
  SELECT Cno, Cname, Ccredit
  FROM Course
  WHERE Cname LIKE "%数据%";
  
  # 查询以“数据”开头，且倒数第三个字为“与”的课程，输出课程名。
  SELECT Cname
  FROM Course
  WHERE Cname LIKE "数据%与_ _";
  ```

### ==3.5多表连接查询、复合条件连接查询、空值查询==

同时设计==两个或两个以上==表的查询称为连接查询

在连接操作中，需在`FROM`子句中==指定需要连接==的表，在`WHERE`子句中==指定连接条件==，常见格式为：

```sql
[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>
[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
```

#### 等值连接

当==连接符号为\===时，称为等值连接，在等值连接中把==完全相同的列去掉一列==为==自然连接==

```sql
# 例
# 查询所有选课学生的学号、姓名、课程号与成绩
# 等值连接
SELECT Student.*, SC.*
FROM Student, SC
WHERE Stduent.Sno = SC.Sno;
# 自然连接
SELECT Student.Sno, Sname, Sgender, Sdept, Cno, Grade
FROM Student, SC
WHERE Stduent.Sno = SC.Sno;

# 查询选修1号课程且成绩在90分以上的学生学号、姓名、所在系及成绩。
SELECT Student.Sno, Sname, Sdept, Grade
FROM Student, SC
WHERE Studen.Sno = SC.Sno AND Cno = "1" AND Grade > 90;

# 查询所有课程及其先修课。输出课程名及先修课的课程名
SELECT A.Cname AS Cname, B.Cname AS Cname_pre
FROM Course AS A, Course B # 连接操作的两个表是同一个表时，为了区分，需在FROM子句中使用AS重命名表
WHERE A.Cpno = B.Cno;

# 查询每个学生选课的总学分，输出学生学号、姓名、总学分，将结果按照总学分降序排序，总学分相同的学生按照学号升序排序
SELECT Student.Sno, Sname, SUM(Credit)
FROM Student, Course, SC
WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno
GROUP BY Student.Sno, Sname
ORDER BY SUM(Credit) DESC, Student.Sno ASC;

# 连接的三种写法
# 查询李博的选课以及对应课程成绩
SELECT Student.Sno, Course.Cno, Grade
FROM Student, Course, SC
WHERE Student.Sno = SC.Sno AND Course. Cno = SC.Cno AND Sname = "李博"

# 内连接
SELECT Student.Sno, Course.Cno, Grade
FROM ((Stduent 
       INNER JOIN SC ON Studnet.Sno = SC.Sno) 
       INNER JOIN Course ON Course.Cno = SC.Cno)
WHERE Sname = "李博";

# 同名字段内连接
SELECT Student.Sno, Course.Cno, Grade
FROM ((Stduent 
       INNER JOIN SC USING(Sno)) 
       INNER JOIN Course USING(Cno))
WHERE Sname = "李博";

# 外连接
# 外连接是连接运算的扩展，用来处理缺失值
# 左外连接取出左表中所有与右表中的任一元组都不匹配的元组，用空值填充所有右表中的属性，再将所产生的元组加到左表和右表自然连接的结果中。
# 右外连接取出右表中所有与左表中的任一元组都不匹配的元组，用空值填充所有左表中的属性，再将所产生的元组加到右表和左表自然连接的结果中。
# 全外连接的查询结果是左外连接和右外连接查询结果的并集。
# 例：
# 将课程表与学生选课表进行左外连接

SELECT Course.Cno, Cname, Cpno, Ccredit, Sno, Grade
FROM Course, SC
WHERE Coures LEFT OUTER JOIN SC ON Course.Cno = SC.Cno;
```

#### **空值查询**

空值就是“不知道”或“不存在”或“无意义”的值

判断一个属性的值是否为空值，用==IS NULL==或==IS NOT NULL==来表示

```sql
# 例
# 找出选修1号课程的不及格的学生
SELECT Sno
FROM SC
WHERE Cno = "1" AND Grade < 60;

# 选出选修1号课程的不及格的学生以及缺考的学生
SELECT Sno
FROM SC
WHERE Cno = "1" AND (Grade < 60 OR Grade IS NULL);
# 或者
SELECT Sno
FROM SC
WHERE Grade < 60 AND Cno = "1"
UNION
SELECT Sno
FROM SC
WHERE Grade IS NULL AND Cno = "1";
```

### 3.6 数据更新:插入数据、修改数据、删除数据

在执行插入、修改和删除语句时会检查所插入、修改和删除的元组==是否破坏表中的完整性约束==。如果不满足完整性约束，则可能会执行失败

####  插入数据

- 插入数据

  - 插入单个元组

    ```sql
    INSERT 
    INTO <表名1> [(<列名1>), ..., (<列名n>)]
    VALUES (<常量1>, ..., <常量n>)
    
    # 例
    # 将新元组（学号：2021310726，姓名：李丽，年龄：17，性别：女，所在系：MA）插入到Student表中
    INSERT
    INTO Student (Sno, Sname, Sage, Sgender, Sdept)
    VALUES ("2021310726", "李丽", 17, "女", "MA");
    # INTO子句中的列名可以省略，那么VALUES子句中则要按照表中列的顺序依次列出所有列的取值
    INSERT
    INTO Student
    VALUES ("2021310726", "李丽", 17, "女", "MA");
    ```

  - 插入子查询结果

    语句的含义为将子查询的查询结果插入到指定表的指定列中

    ```sql
    INSERT
    INTO <表名1> [(<列名1>), ..., (<列名n>)]
    子查询;
    
    # 例
    # 对每一个系，求学生总人数，并将结果存入数据库
    # 首先，建立一个系（Department）表，该表包含2列：系名（Dname）列，数据类型为CHAR(20)，和人数（Dnum）列，数据类型为INT
    CREATE TABLE Department 
    (
      Dname CHAR(20),
      Dnum INT
    );
    # 然后，从学生表中查询每个系的学生总人数，并将结果存在系表中
    INSERT
    INTO Department (Dname, Dnum)
    SELECT Sdept, COUNT(*)
    FROM Studnet
    GROUP BY Sdept;
    ```

#### 修改数据

- 修改数据

  语句的含义为更新指定表中==满足WHERE子句中条件==的元组

  将这些元组的列名1，列名2，…，列名n这n个列的取值分别设置为表达式1，表达式2，…，表达式n的取值

  如果不包含WHERE子句，则表中的所有元组都将被修改

  ```sql
  UPDATE <表名>
  SET <列名1> = <表达式1>, ..., <列名n> = <表达式n>
  [WHERE <条件>];
  
  # 例
  # 将学号为2021310721的学生的年龄加一
  UPDATE Student
  SET Sage = Sage + 1
  WHERE Sno = "2021310721";
  # 将所有学生的年龄加一
  UPDATE Student
  SET Sage = Sage + 1;
  ```

#### 删除数据

- 删除数据

  语句的含义为删除指定表中==满足WHERE子句中条件==的元组

  如果不包含WHERE子句，则表中的所有元组都将被删除

  ```sql
  DELETE
  FROM <表名>
  [WHERE <条件>];
  
  # 例
  # 删除学号为2021310721的学生记录
  DELETE
  FROM Student
  WHERE Sno = "2021310721"；
  # 删除学生选课表中的所有选课信息
  DELETE
  FROM Student;
  ```

  

## 第四章 高级SQL

### 4.1 嵌套查询、递归查询和基于派生表的查询

#### **嵌套查询**

一个==SELECT-FROM-WHERE语句==是一个==查询块==,将一个查询块嵌套在另一个查询块的WHERE子句，FROM子句或者HAVING短语的条件中的查询称为==嵌套查询==。

上层的查询称为==外层查询或者父查询==，下层的查询称为==内层查询或者子查询==。

在==求解嵌套查询==时，==先求解子查询==，然后基于子查询的求解结果来求解父查询 

子查询的查询条件==不依赖于父查询==的查询为==不相关子查询==，子查询的查询条件==依赖于父查询==的==某个属性值==的查询为==相关子查询==

```sql
# 例
# 不相关子查询
# 查询选修了1号课程的学生学号、姓名及所在系
SELECT Sno, Sname, Sdept
FROM Student
WHERE Sno IN 			# 当内层查询的查询结果是一个集合时，使用IN、NOT INT、ANY/SOME、ALL
		(
      SELECT Sno
      FROM SC
      WHERE Cno = "1"
  	);

# 有些嵌套查询可以用连接操作实现,如上例可写为
SELECT Studetn.Sno Sname, Sdept
FROM Studnet, SC
WHERE Student.Sno = SC.Sno AND Course = "1";

# 查询选修数据库课程的学生的学号
SELECT Sno
FROM SC
WHERE Cno = 			# 当内层查询的查询结果是一个值（不是集合）时，使用=,>,<,!=等比较运算符
		(
    	SELECT Cno
      FROM Course
      WHERE Cname = "数据库"
    );

# 相关子查询    
# 查询各院系中年龄小于平均年龄的学生信息
SELECT DISTINCT *
FROM Studetn A
WHERE A.Sage <
		(
  		SELECT AVG(B.Sage)
      FROM Student B
      WHERE A.Sdept = B.Sdept
  	); 	
```

##### 带有IN谓词的子查询

```sql
# 例：查询选修了课程名为“信息系统”的学生学号和姓名
SELECT Sno, Sname
FROM Student
WHERE Sno IN 
  (
    SELECT Sno
  	FROM SC
  	WHERE Cno IN 
    (
      SELECT Cno
      FROM Course
      WHERE Cname = "信息系统"
     )
   );
#	用连接查询实现
SELECT Student.Sno, Sname
FROM Student, Course, SC
WHERE Student.Sno = SC.Sno AND
			SC.Cno = Course.Cno AND
			Cname = "信息系统";
```

##### 带有比较运算符的子查询
当能确切知道内层查询返回单值时，可用比较运算符（>，<，=，>=，<=，!=或< >）

```sql
# 例
# 1、查询与“刘晨”在同一个系学习的学生
SELECT Sno, Sname, Sdept
FROM Student
WHERE Sdept = 
		(
    	SELECT Sdpt
      FROM Student
      WHERE Sname = "刘晨"
    );

# 2、找出每个学生超过他选修课程平均成绩的课程号
SELECT Sno, Cno, Grade
FROM SC A
WHERE Grade >=
		(
    	SELECT AVG(Grade)
      FROM SC B
      WHERE B.Sno = A.Sno
    )
```

##### 带有ANY（SOME）或ALL谓词的子查询

使用ANY或ALL谓词时，必须同时使用比较运算符

```sql
# 例
# 1、查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄
SELECT Sname, Sage
FROM Student
WHERE Sage < ANY (SELECT Sage
									FROM Student
                  WHERE Sdept = "CS"
                 ) AND Sdpt <> "CS";
# 用聚集函数实现
SELECT Sname, Sage
FROM Student
WHERE Sage < 
		(
      SELECT MAX(Sage)
      FROM Student
      WHERE Sdept = "CS"
  	);

# 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄
SELECT FROM Sname, Sage
FROM Student
WHERE Sage < ALL (SELECT Sage
                 	FROM Student
                 	WHERE Sdept	= "CS"
                 ) AND Sdept <> "CS";
```

##### 带有EXISTS谓词的子查询

- EXISTS谓词

  带有EXISTS谓词的子查询不返回任何数据，只产生==逻辑真值==`TRUE`或==逻辑假值==`FALSE`

  由EXISTS引出的子查询，其==目标列表达式通常用*==，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义

- NOT EXISTS谓词

  - 若内层查询结果==非空==，则外层的WHERE子句返回==假值==
  - 若内层查询结果为空，则外层的WHERE子句返回真值

```sql
# 例
# 查询所有选修了1号课程的学生姓名
SELECT Sname
FROM Student
WHERE EXISTS
		(
      SELECT *
      FROM SC
      WHERE Cno = "1" AND Sno = Student.Sno
    );

# 查询没有选修1号课程的学生姓名
SELECT Sname
FROM Student
WHERE NOT EXISTS
		(
      SELECT *
      FROM SC
      WHERE Cno = "1" AND Sno = Student.Sno
    );
    
# 查询与“刘晨”在同一个系学习的学生
SELECT Sno, Sname, Sdept
FROM Student A
WHERE EXISTS
		(
    	SELECT *
      FROM Student B
      WHERE B.Sname = "刘晨" 	AND A.Sdept = B.Sdept
    );
    
# 查询选修了全部课程的学生姓名
# 选修全部 = 没有一门不选
SELECT Sname
FROM Student
WHERE NOT EXISTS
		(
    	SELECT *
      FROM Course
      WHERE NOT EXISTS
      		(
          	SELECT *
            FROM SC
            WHERE SC.Sno = Student.Sno AND
            			SC.Cno - Course.Cno
          )
    );
    
# 查询至少选修了学生201215122选修的全部课程的学生号码
SELECT DISTINCT Sno
FROM SC SC1
WHERE NOT EXISTS
		(
    	SELECT *
      FROM SC SC2
      WHERE SC2.Sno = "201215122" AND
      			NOT EXISTS
      			(
            	SELECT *
              FROM SC SC3
              WHERE SC3.Sno = SC1.Sno AND SC3.Cno = SC2.Cno
            )
    );
```

#### 递归查询

- 递归查询

  递归查询可用于实现循环，也可用于求“闭包”，语法格式如下：

  ```sql
  WITH RECURSIVE temporary_table AS (
  		SEED QUERY
    	UNION [ALL]
    	RECURSIVE QUERY
  )
  
  # 例
  # 输出1到100之和
  WITH RECURSIVE num_sum(n) AS (
  	VALUES(1)
    UNION
    SELECT n + 1 FROM num_sum WHERE n < 100
  )
  SELECT SUM(n) FROM num_sum;
  ```

#### 基于派生表的查询

- 基于派生表的查询

  子查询不仅可以出现在WHRER子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表成为主查询的查询对象

  ```sql
  # 例
  # 找出每个学生超过他自己选修课程平均成绩的课程号
  SELECT Cno
  FROM SC, (SELECT Sno, AVG(Grade)
           	FROM SC
            GROUP BY Sno) 
            AS Avg_sc(avg_sno, avg_grade)
  WHERE SC.Grade >= Avg_sc.avg_grade AND
  			SC.Sno = Avg_sc.avg_sno;
  			
  # 如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性
  # 查询所有选修了1号课程的学生姓名
  SELECT Sname
  FROM Student, (SELECT Sno
                 FROM SC
                 WHERE Cno = "1")
                 AS C1_student
  WHERE Studnet.Sno = C1_student.Sno;
  ```

- 集合操作

  SQL语句查询的结果是==元组的集合==，因此可以将查询结果进行集合操作

  SQL中支持的集合操作主要包括==并（UNION）==、==交（INTERSECT==）、==差（EXCEPT）==

  参加集合操作的各==查询结果列数==必须相同，对应的==数据类型==也要相同

  Union/Intersect/Except：去重

  Union/Intersect/Except ==ALL==：不去重

  ```sql
  # 并操作
  # 查询计算机系学生或男生的信息
  (SELECT *
  FROM Studnet
  WHERE Sdept = "CS")
  UNION
  (SELECT *
  FROM Studnet
  WHERE Sgender = "男");
  
  # 交操作
  # 查询计算机系男生的信息
  (SELECT *
  FROM Studnet
  WHERE Sdept = "CS")
  INTERSECT
  (SELECT *
  FROM Studnet
  WHERE Sgender = "男");
  
  # 差操作
  # 查询计算机系女生的信息
  (SELECT *
  FROM Studnet
  WHERE Sdept = "CS")
  EXCEPT
  (SELECT *
  FROM Studnet
  WHERE Sgender = "男");
  ```

### 4.2 数据库的安全性和完整性的定义。

#### 数据库的完整性

- 数据库的完整性

  - 数据的==正确性==

    指数据是符合==现实世界语义==，反映了当前实际情况的

  - 数据的==相容性==

    指数据库==同一对象==在==不同关系表中的==数据是符合逻辑的

- 数据的完整性

  - 防止数据库中存在==不符合语义==的数据，也就是防止数据库中存在==不正确==的数据
  - 防范对象：不合语义的、不正确的数据

- 维护数据库完整性

  - 提供定义完整性约束条件的机制
  - 提供完整性检查的方法
  - 违约处理

#### 数据库的安全性

- 数据库的安全性

  - 保护数据库，防止恶意的破坏和非法的存取
- 数据的安全性

  - 保护数据库，防止恶意的破坏和非法的存取
  - 防范对象：非法用户、非法操作

### 4.3 实体完整性、参照完整性、用户定义完整性、实现数据库安全性控制常用的方法和技术、掌握用户、角色的创建及授权和收回权限

#### 完整性约束

```sql
# 例
# 建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”
CREATE TABLE Student(
  Sno VARCHAR(15),
  CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999),
  Sname VARCHAR(20),
  CONSTRAINT C2 NOT NULL,
  Sage SMALLINT,
  CONSTRAINT C3 CHECK (Sage < 30),
  Ssex VARCHAR(2),
  CONSTRAINT C4 CHECK (Ssex IN ('男', '女')),
  CONSTRAINT StudentPK PRIMARY KEY (Sno)
);


# 建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和
CREATE TABLE TEACHER (
	Tname VARCHAR(20),
  Tno VARCHAR(15) PRIMARY KEY,
  Job VARCHAR(8),
  Sal NUMERIC(7, 2),
  Deduct NUMERIC(7, 2),
	Deptno NUMERIC(2),
  CONSTRAINT C1 CHECK (Sal + Deduct >= 3000),
  CONSTRAINT FOREIGN_KEY FOREIGN KEY(Deptno) REFERENCES DEPT(Deptno)
);

# 去掉Student表中对性别的限制
ALTER TABLE Student
DROP CONSTRAINT C4;

# 增加对性别的限制
ALTER TABLE Student
ADD CONSTRAINT CHECK (Ssex IN ('男', '女'));
```

#### 实现数据库安全性控制

- 存储控制

​	==定义用户权限==，并将用户权限登记到==数据字典==中

​	==合法权限检查==，查找数据字典，进行合法权限检查

​	用户权限定义和合法权检查机制一起组成了数据库管理系统的==存取控制子系统==

- 自主存取控制

  - C2级
  - 用户对不同数据对象有不同的存取权限
  - 不同用户对同一数据对象也有不同的权限
  - 用户还可将其拥有的存取权限转授给其他用户

  缺点：可能存在数据的"==无意泄露=="

  原因：这种机制仅仅通过==对数据的存取权限==来进行安全控制，而==数据本身并无安全性标记==

- 强制存储控制

  - B1级
  - 每一个数据对象被标以一定的密级
  - 每一个用户也被授予某一个级别的许可证
  - 对于任意一个对象，只有具有合法许可证的用户才可以存取

  数据库管理系统所管理的全部实体被分为==主体==和客体两大类

  - ==主体==是系统中的==活动实体==
    - 数据库管理系统所管理的实际用户
    - 代表用户的各进程
  - ==客体==是系统中的==被动实体==，受主体操纵
    - 文件、基本表、索引、视图......
  
  ==敏感度标记==
  
  - 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）
  - 级别：
    - 绝密（Top Secret，TS）
    - 机密（Secret，S）
    - 可信（Confidential，C）
    - 公开（Public，P）
  - ==主体==的敏感度标记称为==许可证级别==（Clearance Level）
  -  ==客体==的敏感度标记称为==密级==（Classification Level）
  
  **==规则==**
  
  - 仅当主体的许可证级别==大于或等于==客体的密级时，该主体才能==读取==相应的客体
  - 仅当主体的许可证级别==小于或等于==客体的密级时，该主体才能==写取==相应的客体
  - 防止高许可证级别的主体恶意降低高密级客体导致数据泄露

#### 用户创建

```sql
CREATE USER <username>
[WITH] [DBA | RESOURCE | CONNECT];
# CREATE USER不是SQL标准，各个系统的实现相差甚远
```

#### 授权和回收权限

```sql
# GRANT语句：将对指定操作对象的指定操作权限授予指定的用户
GRANT <权限>, ..., <权限>
ON <对象类型> <对象名>, ..., <对象类型> <对象名>
TO <用户>, ..., <用户>
[WITH GRANT OPTION]; # WITH GRANT OPTION子句：指定后授权用户可以再授予	没有指定用户不能传播权限

# 例
# 把查询Student表权限授给用户U1
GRANT SELECT
ON TABLE Student
TO U1;

# 把对Student表和Course表的全部权限授予用户U2和U3
GRANT ALL PRIVILEGES
ON TABLE Student, Course
TO U2, U3;

# 把对表SC的查询权限授予所有用户
GRANT SELECT
ON TABLE SC
TO PUBLIC; # TO PUBLIC语句在MySQL是不适用的

# 把查询Student表和修改学生学号的权限授给用户U4
GRANT SELECT, UPDATE(Sno)	# 对属性列的授权时必须明确指出相应属性列名
ON TABLE Student
TO U4;

# 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户
SELECT INSERT
ON TABLE SC
TO U5
WITH GRANT OPTION;
# 执行后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限:
GRANT INSERT
ON TABLE SC
TO U6
WITH GRANT OPTION;


# REVOKE语句：授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回
REVOKE <权限>, ..., <权限>
ON <对象类型> <对象名>, ..., <对象类型> <对象名>
FROM <用户>, ..., <用户> [CASCADE | RESTRICT];

# 例
# 把用户U4修改学生学号的权限收回
REVOKE UPDATE(Sno)
ON TABLE Student
FROM U4;

# 收回所有用户对表SC的查询权限
REVOKE SELECT 
ON TABLE SC 
FROM PUBLIC;

# 把用户U5对SC表的INSERT权限收回
REVOKE INSERT 
ON TABLE SC 
FROM U5 CASCADE ; # 将用户U5的INSERT权限收回的时候应该使用CASCADE，否则拒绝执行该语句
# 如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限
```

#### 角色创建

数据库角色：==被命名的==一组与数据库操作相关的==权限==

```sql
# 角色创建
CREATE ROLE <角色名>

# 给角色授权
GRANT <权限>, ..., <权限>
ON <对象类型> 对象名 
TO <角色>, ..., <角色>;

#将一个角色授予其他的角色或用户
GRANT <角色1>, ..., [<角色2>]
TO <角色3>, [<用户1>], ...
[WITH ADMIN OPTION];
# 该语句把角色授予某用户，或授予另一个角色
# 授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION
# 指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色

# 角色权限的收回
REVOKE <权限>, [<权限>], ...
ON <对象类型> <对象名>
FROM <角色>, [<角色>], ...

# 例
# 通过角色来实现将一组权限授予一个用户
CREATE ROLE R1;

# 使角色R1拥有Student表的SELECT、UPDATE、INSERT权限
GRANT SELECT, UPDATE, INSERT
ON TABLE Student
TO R1;

# 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限
GRANT R1
TO 王平, 张明, 赵玲;

# 可以一次性通过R1来回收王平的这3个权限
REVOKE R1
FROM 王平;

# 角色的权限修改
# 使角色R1在原来的基础上增加Student表的DELETE 权限
GRANT DELETE
ON TABLE Student
TO R1;

# 减少R1的SELECT权限
REVOKE SELECT 
ON TABLE Student
FROM R1;
```

### 4.4 嵌入式SQL、过程化SQL、存储过程与函数、触发器

#### 嵌入式SQL

- 嵌入式SQL

  嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序语言，如==C、C++、Python、Java==，称为宿主语言，简称主语言

  为了区分SQL语句与主语言语句，所有SQL语句必须加前缀`EXEC SQL`

  ```sql
  # 主语言为C语言时，语句格式
  EXEC SQL <SQL语句>;
  
  # 主语言为JAVA时
  # SQL <SQL语句>;
  ```

  - **SQL通信区**（SQL Communication Area）

    - SQLCA是一个数据结构

    - 使用方法：

      ```sql
      EXEC SQL INCLUDE SQLCA
      ```

  - **主变量**

    在==SQL语句中==使用的==主语言程序变量==简称为==主变量==

    - 在SQL语句中使用主变量和指示变量的方法

      ```sql
      BEGIN DECLARE SECTION
      	...
      	...		（说明主变量和指示变量）
      	...
      END DECLARE SECTION
      ```

      - 使用主变量
        - 说明之后的主变量可以在SQL语句中==任何一个能够使用表达式的地方==出现
        - 为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加==冒号(:)==作为标志
      - 使用指示变量
        - 指示变量前也必须加==冒号==标志
        - 必须紧跟在==所指主变量之后==

  - **游标**

    游标是系统为用户开设的一个==数据缓冲区==，存放==SQL语句的执行结果==

    每个游标区都有一个名字

    用户可以用SQL语句逐一从游标中获取记录。并赋给主变量，交由主语言处理。

    - **为什么使用游标**
      - SQL语言与主语言有不同的==数据处理方式==
      - SQL语言是面向集合的，==一条SQL语句==原则上可以产生或处理==多条记录==
      - 主语言是面向记录的，==一组主变量==一次只能存放==一条记录==
      - 仅使用主变量并不能完全满足SQL语句向应用程序输出的数据请求
      - 嵌入式SQL引入游标，用来协调这两种不同的处理方式

  - 程序实例

    ```sql
    #  依次检查某个系的学生记录，交互式更新某些学生年龄
    
    EXEC SQL BEGIN DECLARE SECTION;		/* 主变量说明开始 */
    	char Deptname[20];
    	char Hsno[9];
    	char Hsname[20];
    	char Hssex[2];
    	int HSage;
    	int NEWAGE;
    EXEC SQL END DECLARE SECTION;		/* 主变量说明结束 */
    long SQLCODE;
    EXCE SQL INCLUDE SQLCA;					/* 定义SQL通信区 */
    
    int main(void) 									/* C语言主程序开始 */
    {
      int count = 0;
      char yn; 											/* 变量yn代表yes或no */
      printf("Please choose the department name(CS/MA/IS): "); 
      scanf("%s",deptname); 				/* 为主变量deptname赋值 */
      EXEC SQL CONNECT TO TEST@localhost:54321 USER
      "SYSTEM"/"MANAGER"; 					/* 连接数据库TEST */
      EXEC SQL DECLARE SX CURSOR FOR 				/* 定义游标SX */
      SELECT Sno,Sname,Ssex,Sage 						/* SX对应的语句 */
      FROM Student
      WHERE SDept = :deptname;
      EXEC SQL OPEN SX; 						/* 打开游标SX，指向查询结果的第一行 */
      for ( ; ; ) 									/* 用循环结构逐条处理结果集中的记录 */
      { 
        EXEC SQL FETCH SX INTO :HSno,:Hsname,:HSsex,:HSage;		/* 推进游标，将当前数据放入主变量 */
        if (SQLCA.SQLCODE!= 0) 			/* SQLCODE != 0，表示操作不成功 */
        break; 											/* 利用SQLCA中的状态信息决定何时退出循环 */
        if(count++ == 0) 						/* 如果是第一行的话，先打出行头 */
        printf("\n%-10s %-20s %-10s %-10s\n",
        				"Sno", "Sname", "Ssex", "Sage");
        printf("%-10s %-20s %-10s %-10d\n",
        				HSno, Hsname, Hssex, HSage); /*打印查询结果*/
        printf(“UPDATE AGE(y/n)?”); /*询问用户是否要更新该学生的年龄*/
        do{scanf("%c",&yn);}
       	while(yn != 'N' && yn != 'n' && yn != 'Y' && yn != 'y');
       	if (yn == 'y' || yn == 'Y') /*如果选择更新操作*/
      	{
        printf("INPUT NEW AGE:");
        scanf("%d",&NEWAGE); 				/* 用户输入新年龄到主变量中 */
        EXEC SQL UPDATE Student 		/* 嵌入式SQL更新语句 */
        SET Sage = :NEWAGE
        WHERE CURRENT OF SX;
        } 													/* 对当前游标指向的学生年龄进行更新 */
      }
      EXEC SQL CLOSE SX; 						/* 关闭游标SX，不再和查询结果对应 */
      EXEC SQL COMMIT WORK; 				/* 提交更新 */
      EXEC SQL DISCONNECT TEST; 		/* 断开数据库连接 */
    }
    ```

#### 过程化SQL

是SQL的扩展，增加了==过程化语句功能==，基本结构是==块==，块之间可以==互相嵌套==，每个块完成==一个逻辑操作==



#### 存储过程与函数



#### 触发器

- 触发器：用户定义在关系表上的一类由==事件驱动==的==特殊过程==
  - 触发器保存在数据库服务器中
  - 任何用户对==表==的==增、删、改操==作均有服务器自动激活==相应的触发器==

- 定义触发器

  ```sql
  CREATE TRIGGER <触发器名>
  {BEFORE | AFTER} <触发事件> ON <表名>
  REFERENCING NEW|OLD ROW AS <变量>
  FOR EACH {ROW | STATEMENT}
  [WHEN <触发事件>] <触发动作体>
  ```


### 4.5 关系数据库理论

#### 1、对函数依赖、码、主属性、非主属性、外码等有深入的理解

问题提出：不适合的数据依赖，造成插入异常、删除异常、更新异常和数据冗余的问题

- 函数依赖

  设R(U)是一个属性集U上的关系模式，X和Y是U的==子集==。若对于R(U)的任意一个可能关系r，r中==不可能存在两个元组==在

  X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X”，记作$X \rightarrow Y$​。

  - 平凡函数依赖：在关系模式R(U)中，对于U的子集X和Y，如果$X \rightarrow Y$，且$Y \subseteq X$，则称$X \rightarrow Y$是平凡函数依赖
  - ==非平凡函数依赖==：在关系模式R(U)中，对于U的子集X和Y，如果$X \rightarrow Y$，且$Y \nsubseteq X$，则称$X \rightarrow Y$​是非平凡函数依赖
  - 完全函数依赖：在R(U)中，如果$X \rightarrow Y$，并且对于X的==任意一个真子集==$X^{'}$，都有$X^{'} \nrightarrow Y$，则称Y完全函数依赖于X
  - 部分函数依赖：在R(U)中，如果$X \rightarrow Y$，但Y不完全函数依赖于X，则称Y部分函数依赖于X

- 码

  - 候选码

     设*K*为*R*<*U*,*F*>中的属性或属性组合。若$K^F \rightarrow U$，则*K*称为*R*的一个候选码

    如果==*U*部分函数依赖于*K*==，即$K^P \rightarrow U$​,则*K*称为==超码==（Surpkey）。==候选码是最小的超码==，即*K*的任意一个真子集都不是候选码。

  - 主码

    若关系模式R有多个候选码，则选定其中一个作为==主码==

  - 主属性与非主属性

    - 主属性：包含在任何一个候选码中属性
    - 非主属性：不包含在任何码中的属性

  - 外码

    关系模式 R(U,F)，==U中属性或属性组X== 并非 R的码，但 X 是另一个关系模式的码，则称X 是R 的外部码（Foreign key）也称==外码==


#### 2、掌握关系模式的基本函数依赖、关系模式的候选码

#### 3、掌握数据库规范化理论，能够判断给定关系模式的规范化程度

- 范式：符合某一种级别的关系模式的集合

  - 第一范式（1NF）

    如果一个关系模式R得所有属性都是不可分的基本数据项，则$R \in 1NF$

    第一范式是对关系模式最起码的要求

  - 第二范式（2NF）

    若关系模式$R \in 1NF$，并且每一个==非主属性==都==完全函数依赖==于R的码，则$R \in 2NF$

  - 第三范式（3NF）

    设关系模式$R \in 1NF$,若*R*中不存在这样的码*X*、属性组*Y*及非主属性*Z*（ $Z \nsubseteq Y$ ）, 使得$X \rightarrow Y, Y \rightarrow Z, Y \nrightarrow X $成立，则称$R \in 3NF$​

    第三范式是在第二范式基础上消除传递函数依赖

  - BC范式（BCNF）

    设关系模式$R \in 1NF$，如果对于R中的每个函数依赖$X \rightarrow Y$且$Y \nsubseteq X$时，X必含有码，则$R \in BCNF$​

    在关系模式*R*<*U*,*F*>中，如果每一个决定因素都包含码，则$R \in BCNF$​

    性质：

    - 所有==非主属性==对每一个码都是==完全函数依赖==
    - 所有==主属性==对每一个==不包含它的码==都==完全函数依赖==
    - 没有任何属性==完全函数依赖于非码==的任何一组属性
    - ![截屏2024-12-12 下午5.33.38](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-12 下午5.33.38.png)

  - 第四范式（4NF）

  - 第五范式（5NF）

#### 4、掌握模式的分解,能够按要求对给定关系模式进行分解，修改为符合更高一级的范式

- 规范化

  一个低一级范式的关系模式，通过==模式分解==可以转换为若干个高一级范式的关系模式的集合的过程

### 4.6 数据依赖的公理系统

#### Armstrong公理系统

- Armstrong公理系统

  设U为属性集总体，F是U上的一组函数依赖， 于是有关系模式R <U,F >。

  对R <U,F> 来说有以下的推理规则：

  - A1 自反律（reflexivity rule）：若$Y \subseteq X \subseteq U $，则X→Y为F所蕴涵。
  -  A2 增广律（augmentation rule）：若X→Y为F所蕴涵，且$Z \subseteq U$，则XZ→YZ 为F所蕴涵。
  -  A3 传递律（transitivity rule）：若X→Y及Y→Z为F所蕴涵，则X→Z 为F所蕴涵。

- 闭包

  在关系模式R<U,F>中为F所==逻辑蕴涵的函数依赖的全体==叫作F的闭包，记为$F^+$​ 。

  设F为属性集U上的一组函数依赖，$X、Y \subseteq U$， $X_{F^+} = {A|X \rightarrow A能由F根据Armstrong公理导出}$，$X_{F^+}$称为属性集X关于函数依赖集F的闭包。

  - ==求闭包==：

    - 例：已知关系模式R<U, F>，其中U={A, B, C, D, E}；F={AB→C, B→D, C→E, EC→B, AC→B}。求$(AB)_{F^+}$

      解：$设X^{(0)} = AB$​

      计算$X^{(1)}$:逐一扫描F集合中的各个函数依赖，找左部为A、B或AB的函数依赖：$AB \rightarrow C, B \rightarrow D$。于是$X^{(1)} = AB \cup CD = ABCD$

      因为$X^{(0)} \neq X^{(1)}$，所以再找出左部为ABCD子集的那些函数依赖，得到$C \rightarrow E, AC \rightarrow B$，于是

      $X^{(2)} = X^{(1)} \cup BE = ABCDE$

      因为$X^{(2)}$已经等于全部属性集合，所以$(AB)_{F^+} = ABCDE$

- 最小函数依赖

  如果函数依赖集F满足以下条件，则称F为一个==极小函数依赖集==。也称为==最小依赖集==或==最小覆盖==。

  (1)F中==任一==函数依赖的==右部仅含有一个属性==

  (2)F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价

  (3)F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。

  > [!TIP]
  >
  > - 简记为：右端单个，无多余依赖，左端最简

  例：关系模式R(U，F)中，U=ABCDEG，$F={B \rightarrow D，DG \rightarrow C,BD \rightarrow E,AG \rightarrow B,ADG \rightarrow BC}$​；求F的最小函数依赖集

  解：(1)用分解法则，使F中的任意一个函数依赖的右部仅含有一个属性，得到：$F = {B \rightarrow D, DG \rightarrow C, BD \rightarrow E, AG \rightarrow  B, ADG \rightarrow B, ADG \rightarrow C}$;

  (2)去掉多余的函数依赖：从第一个函数依赖$X \rightarrow Y$开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，依次做下去，直到找不到冗余的函数依赖：

  ① 去掉B->D，此时F={DG->C,BD->E,AG->B,ADG->B，ADG->C}，此条件下得出B的闭包 B+ =  B；B+不包含D，所以B->D保留。 

  ②去掉DG->C，此时F={B->D,BD->E,AG->B,ADG->B，ADG->C}，此时DG闭包DG+ = DG，不包含C,所以不能去掉DG->C.  

  ③ 去掉BD->E，此时F={B->D，DG->C,AG->B,ADG->B，ADG->C}，此时闭包BD+ = BD,不包含E，所以不能去掉BD->E，继续保留。

  ④去掉AG->B，此时F={B->D，DG->C,BD->E,ADG->B，ADG->C}；此时AG+ = AG，不包含B，所以不能去掉AG->B，继续保留。

  ⑤去掉ADG->B，此时F={B->D，DG->C,BD->E,AG->B,ADG->C}，此时ADG+ = ADGCBE,包含了B，所以删除ADG->B，不保留。

  ⑥去掉ADG->C，此时F={B->D，DG->C,BD->E,AG->B}，此时ADG+ = ADGCBD,包含了C，所以删除ADG->C，不保留。

  综上所得，此时得到F={B->D，DG->C,BD->E,AG->B}；

  (3)去掉各依赖左部多余的属性：一个一个地检查函数依赖左部非单个属性的依赖，此时函数依赖左边非单个属性有：$DG \rightarrow C,BD \rightarrow E,AG \rightarrow B$​；所以做如下操作：

  ①先来看DG->C，首先去掉D，则此时G的闭包G+ = G，不包含C，保留D。再次去掉G，此时D+ = D，不包含C，所以G也不能去掉；②再来看BD->E，首先去掉B，得到此时D的闭包D+ = D，不含E，保留B。然后去掉D，此时B+ = BDE，包含了E，所以去掉D，即得出：B->E;

  ③最后再来看AG->B，去掉A，G+ = G，不包含B，不能去掉A。去掉G的时候，A的闭包A+ =A，不含B，不能去掉A，还是AG->B ；所以最后得出：F的最小函数依赖集是：F={B->D，DG->C,B->E,AG->B}；

### 4.7 关系数据库设计

#### 1、掌握数据库的一般设计过程及每个阶段的主要任务。

- 数据库设计

  数据库设计是指对于一个给定的应用环境，构造（设计）一个优良的数据库==逻辑模式==和==物理结构==，并据此建立数据库及其应用系统，是指能够在有效的==存储和管理数据==，满足各种用户的==应用需求==，包括==信息管理要求==和数据操作要求。

  - 数据库设计的目标是为用户和各种应用系统提供一个==信息基础设施==和高效率的==运行环境==。

- 数据库的一般设计过程

  - 需求分析
    - 是否做得==充分==与==明确==，决定了构建数据库的==速度和质量==
  - 概念结构设计
    - 通过对用户需求进行==综合、归纳与抽象==，形成一个独立于具体数据库管理系统的==概念模型==
  - 逻辑结构设计
    - 将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化
  - 物理结构设计
    - 为逻辑结构选取一个==最适合应用环境的物理结构==
    - 包括存储结构和存储方法
  - 数据库实施
    - 根据逻辑设计和物理设计的结果构建数据库
    - 编写与调试应用程序
    - 组织数据入库并进行试运行
  - 数据库运行和维护
    - 经过试运行后即可投入正式运行
    - 在运行过程中必须不断对其进行==评估、调整与修改==

#### 2、根据语义设计系统的E-R图，并将E-R图转换为关系模式（写出关系名称和所有属性）

- 实体-联系方法（Entity-Relationship Approach）

  用E-R图来描述现实世界的概念模型，E-R方法也称E-R模型

  - 实体之间的联系

    - 两个实体型之间的联系

      - 一对一（1 : 1）

      - 一对多（1 : n）

      - 多对多（n : n）

        <img src="/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-12 下午9.59.20.png" alt="截屏2024-12-12 下午9.59.20" style="zoom:50%;" />

  - E-R图

    E-R图提供了表示实体型、属性和联系的方法：

    - 实体型：用矩形表示，矩形框内写实体名

    - 属性：用椭圆表示，并用无向边将其与对应的实体型连接

      - 例：

        <img src="/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-12 下午9.41.53.png" alt="截屏2024-12-12 下午9.41.53" style="zoom:50%;" />

    - 联系：用菱形表示，菱形框内写名联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型，联系可以具有属性

      - 例：

        <img src="/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-12 下午9.43.57.png" alt="截屏2024-12-12 下午9.43.57" style="zoom:50%;" />

  例1：某工厂生产若干产品，每种产品由不同的零件组成，有的零件可用在不同的产品。这些零件有不同的原材料制成，不同零件所用的材料可以相同。有的零件可用在不同的产品，这些零件按照所属的不同产品分别放在仓库中，原材料按照类别放在若干仓库中。

  请用E-R图画出此工厂产品、零件、材料、仓库的概念模型。

  

  例2:学校中有若干系，每个系有若干班级和教研室，每个教研室有若干教师，其中有的教授和副教授每人各带若干研究生，每个班有若干学生，每个学生选修若干课程，每门课程可由若干学生选修。请用E-R图画出此学校的概念模型，并加入实体和联系的属性。

  <img src="/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-12 下午10.40.19.png" alt="截屏2024-12-12 下午10.40.19" style="zoom:50%;" />

  - **E-R图向关系模型的转换**

    E-R图由==实体型==、==实体的属性==和==实体型之间的联系==三个要素组成

    将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式

    转换原则

    1. 一个实体型转换为一个关系模式

       - 关系的属性：实体的属性
       - 关系的码：实体的码

    2. 实体型间的联系

       1. 一个1 : 1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并
          1. 转换为一个独立的关系模式
             - 关系的属性：与该联系相连的各实体的码以及联系本身的属性
             - 关系的码：每个实体的码均是该关系的候选码
          2. 与某一端对应的关系模式合并
             - 关系的属性：在该端关系中加入对应关系的码和联系本身的属性
             - 关系的码：不变
       2. 一个1 : n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并
          1. 转换为一个独立的关系模式
             - 关系的属性：与该联系相连的各实体的码以及联系本身的属性
             - 关系的码：n端实体的码
          2. 与n端对应的关系模式合并
             - 关系的属性：在n端关系中加入1端关系的码和联系本身的属性
             - 关系的码：不变
       3. 一个m:n联系转换为一个关系模式
          - 关系的属性：与该联系相连的各实体的码以及联系本身的属性
          - 关系的码：各实体码的组合
       4. 三个或三个以上实体间的一个多元联系转换为一个关系模式
          - 关系的属性：与该多元联系相连的各实体的码以及联系本身的属性
          - 关系的码：各实体码的组合
       5. 具有相同码的关系模式可以合并
          - 关系的属性：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性（可能同名也可能不同名）
          - 关系的码：不变

       例：“选修”联系是一个m:n联系，可以将它转换为如下关系模式，其中学号与课程号为关系的组合码：

       ​	选修(<u>学号</u>，<u>课程号</u>， 成绩)

       例：

       <img src="/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-13 上午9.00.47.png" alt="截屏2024-12-13 上午9.00.47" style="zoom:50%;" />

       答：

       - 部门（<u>部门号</u>，部门名，经理的职工号，……）
       - 职工（<u>职工号</u>，部门号，职工名，职位，……）
       - 产品（<u>产品号</u>，产品名，产品组长的职工号，……）
       - 供应商（<u>供应商号</u>，姓名，……）
       - 零件（<u>零件号</u>，零件名，……）
       - 职工工作（<u>职工号</u>，<u>产品号</u>，工作天数，……）
       - 供应（<u>供应商号，产品号，零件号</u>，供应量）

  - 子系统E-R图的冲突

    - 属性冲突
    - 命名冲突
    - 结构冲突

#### 3、对数据库设计方面有自己独到的理解

 

## 第五章 存储管理

### 5.2 数据库的逻辑和物理组织方式、记录表示、块的组织、关系表的组织

#### 数据库的逻辑和物理组织方式

- **表空间-段-分区-数据块**（==逻辑结构==）
  - 分区和段相结合，能够增加==灵活性==
  - 表和块相结合，能够更好地==平衡性能==，方便管理
  - 表空间：
    - 对应磁盘上一个或多个物理数据文件，一个物理文件只能属于一个表空间
  - 段：
    - 由多个分区组成
  - 分区
    - 由一组连续的数据块组成
  - 数据块
    - 磁盘存取单元，大小必须等于服务器操作系统块的大小或倍数
- **文件-块-记录**（==物理结构==）
  - 每个文件物理上分成定长的存储单元，即操作系统的物理块
  - 一个物理块可以存放表中的多条元组（记录）

#### 记录表示

- 记录表示

  - 定长记录

    - 每一条记录在块内从==4的倍数的字节处==开始

    - 记录中所有的字段都从与记录偏移量为4的倍数的字节处开始 

      ![截屏2024-12-13 上午9.27.16](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-13 上午9.27.16.png)

  - 变长记录

    - 变长字段前加长度 

    - 先放定长字段，后放变长字段

    - 变长字段单独存放在一个块中

      ![截屏2024-12-13 上午9.27.35](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-12-13 上午9.27.35.png)

### 5.3 元数据存储

### 5.4缓冲区管理

 

## 第六章 索引

掌握各种索引结构，例如B+树索引、哈希索引和Bitmap索引。特别是哈希索引的相关操作。

 

## 第七章 查询处理

7.2 查询编译概述、词法与语法分析、语义分析、查询优化

重点掌握如何通过查询语句生成语法树、通过语法树经语义分析生成关系代数表达式树、如何通过依据数据库的规则系统对查询树进行转换，并进行查询优化【逻辑优化（代数优化）】

7.3掌握不同的物理操作符（扫描、排序、连接、去除重复值、分组、集合）【物理优化】

 

## 第八章 查询优化

查询优化的==意义==（目标）：查询优化既是关系数据库管理系统实现的关键技术，他减轻了用户==选择存取路径==以及==如何更好地表达查询==以获得较高的效率的负担

### 8.2 关系代数表达式等价变换规则（逻辑优化的主要策略）

- 关系代数表达式等价变换

  - 规则1:选择的分解规则

    $\sigma_{F_1 \and F_2}(E) = \sigma_{F_1}(\sigma_{F_2}(E)) = \sigma_{F_2}(\sigma_{F_1}(E))$​ 

    $\sigma_{F_1 \or F_2}(E) = \sigma_{F_1}(E) \cup \sigma_{F_2}(E)$​​

    例：对于关系R(a,b,c)，R在属性a上有索引，对于$\sigma_{𝑎=1 \and 𝑏=1}(𝑅)$可以转化为$\sigma_{𝑏=1}(\sigma_{𝑎=1}(𝑅))$

  - 规则2:选择与笛卡尔积、连接运算的分配律

    $\sigma_\theta(E_1 \times E_2) = E_j \Join_{\theta} E_k$​

    $\sigma_{\theta_1}(E_j \Join_{\theta_2} E_k) = E_j \Join_{\theta_1 \and \theta_2} E_k$​

    例：关系R(a,b)和S(b,c),对于表达式𝜎 a=1∨a=3 ∧ c<10 R ⋈ S，通过变换把选择谓词下推到关系上，先进行选择操作，再进行连接操作𝜎（a=1∨a=3） （R） ⋈ 𝜎（c<10） （S）

  - 规则3:选择与集合操作的分配律
  - 规则4:投影的串接规则
  - 规则5:投影与选择运算的交换

## 第十章 事务处理概述

10.1事务的基本概念及事务的ACID特性

10.2 事务异常与隔离级别

10.3 调度与串行调度、可串行化调度（正确的调度）、冲突可串行化调度

 

## 第十一章 并发控制

### 11.1 两阶段封锁协议与冲突可串行化，判断一个并发调度是不是冲突可串行化调度。活锁和死锁，死锁的预防、诊断与解除

### 两阶段封锁协议

- 两阶段封锁协议
  - 锁
    - 排它锁（写锁）
    - 共享锁（读锁）

### 冲突可串行化

11.2 基于时间戳的并发访问控制（TO）、TO存在的问题“级联回滚”。及解决方案。

11.3了解乐观并发访问控制（OCC）

11.4封锁技术及基本封锁类型（排他锁和共享锁）、三级封锁协议

11.5封锁粒度及多粒度封锁。

 

## 第十二章 数据库恢复技术

12.1 理解数据库系统中故障的种类

12.2掌握数据库恢复技术（日志文件、数据转储或数据备份）

12.3掌握并能熟练使用具有检查点的恢复技术。