# 第26章（1-4）

## 1．开始，我们来看一个简单的程序，“loop.s”。

首先，阅读这个程序，看看你是否能理解它：cat loop.s。然后，用这些参数运行它：

./x86.py -p loop.s -t 1 -i 100 -R dx 

这指定了一个单线程，每 100 条指令产生一个中断，并且追踪寄存器%dx。你能弄清楚%dx 在运行过程中的价值吗？你有答案之后，运行上面的代码并使用-c 标志来检查你的答案。注意答案的左边显示了右侧指令运行后寄存器的值（或内存的值）

<img src="截屏2024-05-07 下午5.24.53.png" alt="截屏2024-05-07 下午5.24.53" style="zoom:67%;" />

### 解释loop.s:

README中指令解释：

<img src="截屏2024-05-07 下午5.00.38.png" alt="截屏2024-05-07 下午5.00.38" style="zoom:67%;" />

```assembly
.main
.top
sub  $1,%dx		/*	%dx寄存器的值减1，结果存入%dx中	*/
test $0,%dx   /*	%dx寄存器的值与0比较，设置标志位 */
jgte .top     /*	如果%dx寄存器的值大于等于0，则跳转到标号 .top处 */
halt					/* 	结束线程	*/
```

### 运行loop.s:

<img src="截屏2024-05-07 下午5.26.45.png" alt="截屏2024-05-07 下午5.26.45" style="zoom:67%;" />

###### 部分运行参数解释：

-t 1：指定了一个单线程

-i 100：中断频率，指定每100条指令中断一次

-R dx：追踪dx寄存器的值

其余参数默认

### 答案

```sh
   dx          Thread 0         

    0   											# dx的初始值为0
    -1   1000 sub  $1,%dx			# dx寄存器中值减1并保存到dx中，此时dx中的值为-1
    -1   1001 test $0,%dx			# dx寄存器中的值 -1 与 0 比较
    -1   1002 jgte .top				# -1 小于 0，不跳转
    -1   1003 halt						#停机
```

<img src="截屏2024-05-07 下午5.27.03.png" alt="截屏2024-05-07 下午5.27.03" style="zoom:67%;" />

## 2．现在运行相同的代码，但使用这些标志：

./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx 

这指定了两个线程，并将每个%dx 寄存器初始化为 3。%dx 会看到什么值？使用-c 标志运行以查看答案。多个线程的存在是否会影响计算？这段代码有竞态条件吗？

### 运行参数：

-t 2：指定两个线程

-a dx=3,dx=3：指定线程0的dx初始值为3，线程0的dx初始值为3

<img src="截屏2024-05-07 下午5.28.08.png" alt="截屏2024-05-07 下午5.28.08" style="zoom:67%;" />

### 答案：

```shell
   dx          Thread 0                Thread 1         

    3   																								# 线程0 dx寄存器初始值为3
    2   1000 sub  $1,%dx																# dx的值循环减1，直到dx的值小于0
    2   1001 test $0,%dx
    2   1002 jgte .top
    1   1000 sub  $1,%dx
    1   1001 test $0,%dx
    1   1002 jgte .top
    0   1000 sub  $1,%dx
    0   1001 test $0,%dx
    0   1002 jgte .top
   -1   1000 sub  $1,%dx
   -1   1001 test $0,%dx
   -1   1002 jgte .top																	# dx的值小于0，退出循环
   -1   1003 halt																				# 线程0运行结束
    3   ----- Halt;Switch -----  ----- Halt;Switch -----# 线程0运行结束，线程1开始运行，dx值为3 
    2                            1000 sub  $1,%dx				
    2                            1001 test $0,%dx
    2                            1002 jgte .top
    1                            1000 sub  $1,%dx
    1                            1001 test $0,%dx
    1                            1002 jgte .top
    0                            1000 sub  $1,%dx
    0                            1001 test $0,%dx
    0                            1002 jgte .top
   -1                            1000 sub  $1,%dx
   -1                            1001 test $0,%dx
   -1                            1002 jgte .top 
   -1                            1003 halt							# 线程1运行结果和线程0的相同
```

<img src="截屏2024-05-07 下午3.52.57.png" alt="截屏2024-05-07 下午3.52.57" style="zoom:67%;" />

根据运行结果来看，多个线程的存在不会影响个线程中变量的计算，这段代码没有竞态条件，因为每个线程退出循环为条件都是dx寄存器中的值小于0时退出，每次循环dx的值都递减1，所以最终结果都会是0。

## 3．现在运行以下命令： 

./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx 

这使得中断间隔非常小且随机。使用不同的种子和-s 来查看不同的交替。中断频率是否会改变这个程序的行为？

### 运行参数：

-i 3：中断频率为3

-r：随机中断

这两个参数使得中断间隔非常小且随机

### 种子0：

<img src="截屏2024-05-07 下午5.34.51.png" alt="截屏2024-05-07 下午5.34.51" style="zoom: 67%;" />.

### 种子1:

<img src="截屏2024-05-07 下午5.35.45.png" alt="截屏2024-05-07 下午5.35.45" style="zoom: 67%;" />.

### 种子2:

<img src="截屏2024-05-07 下午5.36.05.png" alt="截屏2024-05-07 下午5.36.05" style="zoom: 67%;" />.

### 种子3:

###### <img src="截屏2024-05-07 下午5.36.28.png" alt="截屏2024-05-07 下午5.36.28" style="zoom: 67%;" />.

可以看到中断频率并没有改变程序的行为，两个线程的寄存器是不共享的，每个线程都有自己的专用寄存器，计算结果互不影响。

## 4．接下来我们将研究一个不同的程序（looping-race-nolock.s）。

该程序访问位于内存地址 2000 的共享变量。简单起见，我们称这个变量为 *x*。使用单线程运行它，并确保你了解它的功能，如下所示：./x86.py -p looping-race-nolock.s -t 1 -M 2000 在整个运行过程中，*x*（即内存地址为 2000）的值是多少？使用-c 来检查你的答案。

<img src="截屏2024-05-07 下午5.37.26.png" alt="截屏2024-05-07 下午5.37.26" style="zoom:67%;" />

### 理解looping-race-nolock.s：

```assembly
# assumes %bx has loop count in it

.main
.top	
# critical section
mov 2000, %ax  # get 'value' at address 2000
add $1, %ax    # increment it
mov %ax, 2000  # store it back
# 这一段将地址2000处的变量加1并保存回地址2000处

# see if we're still looping
sub  $1, %bx
test $0, %bx
jgt .top	
# 这段是根据bx寄存器的值循环执行上述指令，直到bx的值不大于0

halt
```

根据英文注释，这段代码应该是实现的功能是将地址2000处的值循环加1。

### 运行looping-race-nolock.s：

<img src="截屏2024-05-07 下午5.42.45.png" alt="截屏2024-05-07 下午5.42.45" style="zoom:67%;" />

###### 部分运行参数解释：

-M 2000：追踪地址2000处的值

指令中断频率为50

地址中和寄存器中的值默认为0

###### 答案：

```sh
 2000          Thread 0         
    0   
    0   1000 mov 2000, %ax
    1   1001 add $1, %ax
    1   1002 mov %ax, 2000
    1   1003 sub  $1, %bx		# bx = 0 - 1 = -1
    1   1004 test $0, %bx		# bx的值与0比较
    1   1005 jgt .top				#不大于0，退出循环
    1   1006 halt
```

<img src="截屏2024-05-07 下午7.14.11.png" alt="截屏2024-05-07 下午7.14.11" style="zoom:67%;" />