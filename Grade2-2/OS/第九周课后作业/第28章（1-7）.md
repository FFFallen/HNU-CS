# 第28章（1-7）

## 1．

**首先用标志-p flag.s 运行 x86.py。该代码通过一个内存标志“实现”锁。你能理解汇编代码试图做什么吗？**<img src="截屏2024-05-07 下午7.21.17.png" alt="截屏2024-05-07 下午7.21.17" style="zoom: 67%;" />

**使用cat flag.s查看flag.s:**

```assembly
.var flag
.var count

.main
.top

.acquire
mov  flag, %ax      # flag的值保存到ax寄存器
test $0, %ax        # 如果flag值为0，则说明锁没被占用
jne  .acquire       # 否则跳转到标号.acquire处，即自旋
mov  $1, flag       # 将flag的值置为1，表示锁被占用

# critical section
mov  count, %ax     # 获取地址处变量count并保存到ax寄存器
add  $1, %ax        # count+1
mov  %ax, count     # 将count存回内存

# release lock
mov  $0, flag       # 将flag的值置0，表示锁被释放

# see if we're still looping
sub  $1, %bx			
test $0, %bx
jgt .top						# 根据bx的值（bx > 0）从.top处循环

halt
```

综上，汇编代码flag.s试图使用锁来保证临界区内只有一个线程活跃，实现对共享变量count的原子操作。

但这里锁的状态测试与设置不是一个原子操作，所以它也不能保证互斥，例如：

第一个运行的线程0获得锁后，在执行mov  $1, flag更新锁的状态前，时钟中断，切换到了线程1，此时flag还是0，线程1也会获得锁，此时两个线程都拥有锁，没有互斥，如果有线程在临界区mov  %ax, count处中断，则count的值就只执行了一次递增操作。

## 2．

**使用默认值运行时，flag.s 是否按预期工作？它会产生正确的结果吗？使用-M 和-R 标志跟踪变量和寄存器（并打开-c 查看它们的值）。你能预测代码运行时标志最终会变成什么值吗？**

<img src="截屏2024-05-07 下午7.58.27.png" alt="截屏2024-05-07 下午7.58.27" style="zoom: 67%;"/>

根据运行结果来看，flag按预期操作，count也产生了正确结果，根据汇编代码，程序运行结束前会将锁释放，所以flag最终会变为0。

## 3．

**使用-a 标志更改寄存器%bx 的值（例如，如果只运行两个线程，就用-a bx = 2，bx = 2）。代码是做什么的？对这段代码问上面的问题，答案如何？**

设置参数：

```sh
 ./x86.py -p flag.s -t 2 -a bx=2,bx=2 -R bx -M count,flag -c
```

<img src="截屏2024-05-07 下午8.21.31.png" alt="截屏2024-05-07 下午8.21.31" style="zoom:67%;" />

代码是计算count累加4次的值（每个线程循环2次，两个线程共4次），flag按预期操作，count值结果正确为4，flag最终为0。

## 4．

**对每个线程将 bx 设置为高值，然后使用-i 标志生成不同的中断频率。什么值导致产生不好的结果？什么值导致产生良好的结果？**

### **bx = 50, i = 200**

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 200 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.30.04.png" alt="截屏2024-05-07 下午8.30.04" style="zoom:67%;" />

**bx = 50, i = 150**

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 150 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.30.04.png" alt="截屏2024-05-07 下午8.30.04" style="zoom:67%;" />

### bx = 50, i = 100

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 100 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.32.06.png" alt="截屏2024-05-07 下午8.32.06" style="zoom:67%;" />

### bx = 50, i = 75

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 75 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.35.45.png" alt="截屏2024-05-07 下午8.35.45" style="zoom:67%;" />

### bx = 50, i = 50

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 50 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.36.58.png" alt="截屏2024-05-07 下午8.36.58" style="zoom:67%;" />

### bx = 50, i = 25

#### 运行：

```sh
./x86.py -p flag.s -t 2 -a bx=50,bx=50 -i 25 -R bx -M count,flag -c
```

#### count结果：

<img src="截屏2024-05-07 下午8.37.14.png" alt="截屏2024-05-07 下午8.37.14" style="zoom:67%;" />

### 对比分析：

可以看到当bx的值较高而中断间隔很小时，count的结果会出错，产生坏的结果，当中断间隔较大时，count结果是好的。

## 5．

**现在让我们看看程序 test-and-set.s。首先，尝试理解使用 xchg 指令构建简单锁原语的代码。获取锁怎么写？释放锁如何写？**

### 查看test-and-set.s：

<img src="截屏2024-05-07 下午8.44.48.png" alt="截屏2024-05-07 下午8.44.48" style="zoom: 67%;"/>

### README中xchg指令解释：

<img src="截屏2024-05-07 下午8.49.34.png" alt="截屏2024-05-07 下午8.49.34" style="zoom:67%;" />

xchg是一个原子操作，实现将寄存器的值写入内存，并将内存旧值返回寄存器。（即交换寄存器和内存中的值）

### 获取锁：

```assembly
.acquire
mov  $1 %ax				# ax置为1
xchg %ax, mutex		# 如果mutex旧值为0，说明锁可用，该线程获取锁，并将锁的标志置为1，此时锁被占用
test $0, %ax			# 
jne	.acquire			# 如果mutex旧值为1，继续循环判断mutex的值（自旋）
```

### 释放锁：

```assembly
mov $0, mutex			# 将mutex的值置0，锁空闲
```



## 6．

**现在运行代码，再次更改中断间隔（-i）的值，并确保循环多次。代码是否总能按预期工作？有时会导致 CPU 使用率不高吗？如何量化呢？**

### bx = 25, i = 1：

#### 运行：

```sh
./x86.py -p test-and-set.s -t 2 -i 1 -a bx=25,bx=25 -M count,mutex -R bx -c
```

#### count结果：

<img src="截屏2024-05-08 上午11.02.17.png" alt="截屏2024-05-08 上午11.02.17" style="zoom:67%;" />

### bx = 25, i = 5：

#### 运行：

```sh
./x86.py -p test-and-set.s -t 2 -i 5 -a bx=25,bx=25 -M count,mutex -R bx -c
```

#### count结果：

<img src="截屏2024-05-08 上午11.02.48.png" alt="截屏2024-05-08 上午11.02.48" style="zoom:67%;" />

### bx = 25, i = 10：

#### 运行：

```sh
./x86.py -p test-and-set.s -t 2 -i 10 -a bx=25,bx=25 -M count,mutex -R bx -c
```

#### count结果：

<img src="截屏2024-05-08 上午11.03.08.png" alt="截屏2024-05-08 上午11.03.08" style="zoom:67%;" />

### bx = 25, i = 50：

#### 运行：

```sh
./x86.py -p test-and-set.s -t 2 -i 50 -a bx=25,bx=25 -M count,mutex -R bx -c
```

#### count结果：

<img src="截屏2024-05-08 上午11.03.33.png" alt="截屏2024-05-08 上午11.03.33" style="zoom:67%;" />

### bx = 25, i = 100：

#### 运行：

```sh
./x86.py -p test-and-set.s -t 2 -i 100 -a bx=25,bx=25 -M count,mutex -R bx -c
```

#### count结果：

<img src="截屏2024-05-08 上午11.03.46.png" alt="截屏2024-05-08 上午11.03.46" style="zoom:67%;" />

综上，根据运行结果分析，代码总能正确工作，因为test_and_set.s代码将锁的状态测试和设置作为一个原子操作，实现了互斥，保证临界区只有一个线程活跃；

但有时会导致CPU利用率不高，例如对单CPU情况下，如果持有锁的线程时钟中断后切换到在等待锁的线程时，等待线程的锁会自旋一个时间片，导致CPU的利用率不高；

量化：（以bx = 10， i = 5 为例）

<img src="截屏2024-05-08 上午11.31.59.png" alt="截屏2024-05-08 上午11.31.59" style="zoom: 67%;" />

<img src="截屏2024-05-08 上午11.33.03.png" alt="截屏2024-05-08 上午11.33.03" style="zoom: 67%;" />

<img src="截屏2024-05-08 上午11.34.10.png" alt="截屏2024-05-08 上午11.34.10" style="zoom: 67%;" />

可以看到线程1总自旋的时长为5个时间片，总时间长为11个时间片，所以CPU利用率为6/11,约为54.5%

## 7．

**使用-P 标志生成锁相关代码的特定测试。例如，执行一个测试计划，在第一个线程中获取锁，但随后尝试在第二个线程中获取锁。正确的事情发生了吗？你还应该测试什么？**

### 运行参数设置：

```sh
./x86.py -t 2 -p test-and-set.s -a bx=5,bx=5 -P 111100000000 -M count,mutex -R bx,ax -c
```

### 部分参数解释：

-t 2：指定两个线程

-P 111100000000：指定何时运行哪个线程，这里指线程1执行4条指令后切换到线程0运行8条指令，并重复这个运行顺序

### 运行结果：

<img src="截屏2024-05-08 下午8.09.50.png" alt="截屏2024-05-08 下午8.09.50" style="zoom:67%;" />

可以看到线程1运行4条指令后，线程1先获得锁，后续线程0尝试获得锁时进入自旋，说明锁确实被线程1占用。线程1再执行4条指令，进入临界区对count值加1后释放锁，后续线程0也可获得锁并成功进入临界区再次对count值+1，最后释放锁。从运行结果来看，代码正确执行其功能。

还应测试锁的公平性，可测试运行：

```sh
./x86.py -t 5 -p test-and-set.s -a bx=5,bx=5,bx=2,bx=3,bx=3 -P 11110000222233334444 -M count,mute
```

运行后分析，test-and-set.s汇编代码实现的自旋锁有较好的公平性，因为每个线程都有公平的机会竞争到锁，获取锁的线程执行完一次对count+1的操作后都会释放锁，此时等待的线程都可以竞争锁，不会出现竞争锁的线程饿死的情况。

以及要测试锁的性能，对于本程序来说，这是一个单CPU的系统，所以等待锁的线程会浪费一个时间片去自旋，浪费CPU周期，性能不是很好。
