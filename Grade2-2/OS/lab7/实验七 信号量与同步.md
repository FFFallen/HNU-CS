

<img src="../../../ref/HNU.png" alt="HNU" style="zoom:80%;" />

# 实验七 信号量与同步

## 信号量结构初始化

**新建 lab7/src/include/prt_sem_external.h 头文件**

```c
#ifndef PRT_SEM_EXTERNAL_H
#define PRT_SEM_EXTERNAL_H

#include "prt_sem.h"
#include "prt_task_external.h"
#if defined(OS_OPTION_POSIX)
#include "bits/semaphore_types.h"
#endif

#define OS_SEM_UNUSED 0
#define OS_SEM_USED   1

#define SEM_PROTOCOL_PRIO_INHERIT 1
#define SEM_TYPE_BIT_WIDTH        0x4U
#define SEM_PROTOCOL_BIT_WIDTH    0x8U

#define OS_SEM_WITH_LOCK_FLAG    1
#define OS_SEM_WITHOUT_LOCK_FLAG 0

#define MAX_POSIX_SEMAPHORE_NAME_LEN    31

#define GET_SEM_LIST(ptr) LIST_COMPONENT(ptr, struct TagSemCb, semList)
#define GET_SEM(semid) (((struct TagSemCb *)g_allSem) + (semid))
#define GET_SEM_TSK(semid) (((SEM_TSK_S *)g_semTsk) + (semid))
#define GET_TSK_SEM(tskid) (((TSK_SEM_S *)g_tskSem) + (tskid))
#define GET_SEM_TYPE(semType) (U32)((semType) & ((1U << SEM_TYPE_BIT_WIDTH) - 1))
#define GET_MUTEX_TYPE(semType) (U32)(((semType) >> SEM_TYPE_BIT_WIDTH) & ((1U << SEM_TYPE_BIT_WIDTH) - 1))
#define GET_SEM_PROTOCOL(semType) (U32)((semType) >> SEM_PROTOCOL_BIT_WIDTH)

struct TagSemCb {
    /* 是否使用 OS_SEM_UNUSED/OS_SEM_USED */
    U16 semStat;
    /* 核内信号量索引号 */
    U16 semId;
#if defined(OS_OPTION_SEM_RECUR_PV)
    /* 二进制互斥信号量递归P计数，计数型信号量和二进制同步模式信号量无效 */
    U32 recurCount;
#endif
    /* 当该信号量已用时，其信号量计数 */
    U32 semCount;
    /* 挂接阻塞于该信号量的任务 */
    struct TagListObject semList;
    /* 挂接任务持有的互斥信号量，计数型信号量信号量无效 */
    struct TagListObject semBList;

    /* Pend到该信号量的线程ID */
    U32 semOwner;
    /* 信号量唤醒阻塞任务的方式 */
    enum SemMode semMode;
    /* 信号量，计数型或二进制 */
    U32 semType;
#if defined(OS_OPTION_POSIX)
    /* 信号量名称 */
    char name[MAX_POSIX_SEMAPHORE_NAME_LEN + 1]; // + \0
    /* sem_open 句柄 */
    sem_t handle;
#endif
};

/* 模块间全局变量声明 */
extern U16 g_maxSem;

/* 指向核内信号量控制块 */
extern struct TagSemCb *g_allSem;

extern U32 OsSemCreate(U32 count, U32 semType, enum SemMode semMode, SemHandle *semHandle, U32 cookie);
extern bool OsSemBusy(SemHandle semHandle);

#endif /* PRT_SEM_EXTERNAL_H */
```

**新建 src/kernel/sem/prt_sem_init.c 文件。**

```c
#include "prt_sem_external.h"
#include "os_attr_armv8_external.h"
#include "os_cpu_armv8_external.h"

OS_SEC_BSS struct TagListObject g_unusedSemList;
OS_SEC_BSS struct TagSemCb *g_allSem;

extern void *OsMemAllocAlign(U32 mid, U8 ptNo, U32 size, U8 alignPow);
/*
* 描述：信号量初始化
*/
OS_SEC_L4_TEXT U32 OsSemInit(void)
{
    struct TagSemCb *semNode = NULL;
    U32 idx;
    U32 ret = OS_OK;

    g_allSem = (struct TagSemCb *)OsMemAllocAlign((U32)OS_MID_SEM,
                                                0,
                                                4096,
                                                OS_SEM_ADDR_ALLOC_ALIGN);

    if (g_allSem == NULL) {
        return OS_ERRNO_SEM_NO_MEMORY;
    }

    g_maxSem = 4096 / sizeof(struct TagSemCb);

    char *cg_allSem = (char *)g_allSem;
    for(int i = 0; i < 4096; i++)
        cg_allSem[i] = 0;

    INIT_LIST_OBJECT(&g_unusedSemList);
    for (idx = 0; idx < g_maxSem; idx++) {
        semNode = ((struct TagSemCb *)g_allSem) + idx; //指针操作
        semNode->semId = (U16)idx;
        ListTailAdd(&semNode->semList, &g_unusedSemList);
    }

    return ret;
}

/*
* 描述：创建一个信号量
*/
OS_SEC_L4_TEXT U32 OsSemCreate(U32 count, U32 semType, enum SemMode semMode,
                            SemHandle *semHandle, U32 cookie)
{
    uintptr_t intSave;
    struct TagSemCb *semCreated = NULL;
    struct TagListObject *unusedSem = NULL;
    (void)cookie;

    if (semHandle == NULL) {
        return OS_ERRNO_SEM_PTR_NULL;
    }

    intSave = OsIntLock();

    if (ListEmpty(&g_unusedSemList)) {
        OsIntRestore(intSave);
        return OS_ERRNO_SEM_ALL_BUSY;
    }

    /* 在空闲链表中取走一个控制节点 */
    unusedSem = OS_LIST_FIRST(&(g_unusedSemList));
    ListDelete(unusedSem);

    /* 获取到空闲节点对应的信号量控制块，并开始填充控制块 */
    semCreated = (GET_SEM_LIST(unusedSem));
    semCreated->semCount = count;
    semCreated->semStat = OS_SEM_USED;
    semCreated->semMode = semMode;
    semCreated->semType = semType;
    semCreated->semOwner = OS_INVALID_OWNER_ID;
    if (GET_SEM_TYPE(semType) == SEM_TYPE_BIN) {
        INIT_LIST_OBJECT(&semCreated->semBList);
#if defined(OS_OPTION_SEM_RECUR_PV)
        if (GET_MUTEX_TYPE(semType) == PTHREAD_MUTEX_RECURSIVE) {
            semCreated->recurCount = 0;
        }
#endif
    }

    INIT_LIST_OBJECT(&semCreated->semList);
    *semHandle = (SemHandle)semCreated->semId;

    OsIntRestore(intSave);
    return OS_OK;
}

/*
* 描述：创建一个信号量
*/
OS_SEC_L4_TEXT U32 PRT_SemCreate(U32 count, SemHandle *semHandle)
{
    U32 ret;

    if (count > OS_SEM_COUNT_MAX) {
        return OS_ERRNO_SEM_OVERFLOW;
    }

    ret = OsSemCreate(count, SEM_TYPE_COUNT, SEM_MODE_FIFO, semHandle, (U32)(uintptr_t)semHandle);
    return ret;
}
```

**在 src/bsp/os_cpu_armv8_external.h 加入定义**

```c
#define OS_SEM_ADDR_ALLOC_ALIGN 2U //按2的幂对齐，即2^2=4字节
```

**新建 src/kernel/sem/prt_sem.c 文件。**

```c
#include "prt_sem_external.h"
#include "prt_asm_cpu_external.h"
#include "os_attr_armv8_external.h"
#include "os_cpu_armv8_external.h"

/* 核内信号量最大个数 */
OS_SEC_BSS U16 g_maxSem;


OS_SEC_ALW_INLINE INLINE U32 OsSemPostErrorCheck(struct TagSemCb *semPosted, SemHandle semHandle)
{
    (void)semHandle;
    /* 检查信号量控制块是否UNUSED，排除大部分错误场景 */
    if (semPosted->semStat == OS_SEM_UNUSED) {
        return OS_ERRNO_SEM_INVALID;
    }

    /* post计数型信号量的错误场景, 释放计数型信号量且信号量计数大于最大计数 */
    if ((semPosted)->semCount >= OS_SEM_COUNT_MAX) {
        return OS_ERRNO_SEM_OVERFLOW;
    }

    return OS_OK;
}


/*
* 描述：把当前运行任务挂接到信号量链表上
*/
OS_SEC_L0_TEXT void OsSemPendListPut(struct TagSemCb *semPended, U32 timeOut)
{
    struct TagTskCb *curTskCb = NULL;
    struct TagTskCb *runTsk = RUNNING_TASK;
    struct TagListObject *pendObj = &runTsk->pendList;

    OsTskReadyDel((struct TagTskCb *)runTsk);

    runTsk->taskSem = (void *)semPended;

    TSK_STATUS_SET(runTsk, OS_TSK_PEND);
    /* 根据唤醒方式挂接此链表，同优先级再按FIFO子顺序插入 */
    if (semPended->semMode == SEM_MODE_PRIOR) {
        LIST_FOR_EACH(curTskCb, &semPended->semList, struct TagTskCb, pendList) {
            if (curTskCb->priority > runTsk->priority) {
                ListTailAdd(pendObj, &curTskCb->pendList);
                // goto TIMER_ADD;
                return;
            }
        }
    }
    /* 如果到这里，说明是FIFO方式；或者是优先级方式且挂接首个节点或者挂接尾节点 */
    ListTailAdd(pendObj, &semPended->semList);

}

/*
 * 描述：从非空信号量链表上摘首个任务放入到ready队列
 */
OS_SEC_L0_TEXT struct TagTskCb *OsSemPendListGet(struct TagSemCb *semPended)
{
    struct TagTskCb *taskCb = GET_TCB_PEND(LIST_FIRST(&(semPended->semList)));

    ListDelete(LIST_FIRST(&(semPended->semList)));
    /* 如果阻塞的任务属于定时等待的任务时候，去掉其定时等待标志位，并将其从去除 */
    if (TSK_STATUS_TST(taskCb, OS_TSK_TIMEOUT)) {
        OS_TSK_DELAY_LOCKED_DETACH(taskCb);
    }

    /* 必须先去除 OS_TSK_TIMEOUT 态，再入队[睡眠时是先出ready队，再置OS_TSK_TIMEOUT态] */
    TSK_STATUS_CLEAR(taskCb, OS_TSK_TIMEOUT | OS_TSK_PEND);
    taskCb->taskSem = NULL;
    /* 如果去除信号量阻塞位后，该任务不处于阻塞态则将该任务挂入就绪队列并触发任务调度 */
    if (!TSK_STATUS_TST(taskCb, OS_TSK_SUSPEND)) {
        OsTskReadyAddBgd(taskCb);
    }

    return taskCb;
}

OS_SEC_L0_TEXT U32 OsSemPendParaCheck(U32 timeout)
{
    if (timeout == 0) {
        return OS_ERRNO_SEM_UNAVAILABLE;
    }

    if (OS_TASK_LOCK_DATA != 0) {
        return OS_ERRNO_SEM_PEND_IN_LOCK;
    }
    return OS_OK;
}

OS_SEC_L0_TEXT bool OsSemPendNotNeedSche(struct TagSemCb *semPended, struct TagTskCb *runTsk)
{
    if (semPended->semCount > 0) {
        semPended->semCount--;
        semPended->semOwner = runTsk->taskPid;

        return TRUE;
    }
    return FALSE;
}

/*
* 描述：指定信号量的P操作
*/
OS_SEC_L0_TEXT U32 PRT_SemPend(SemHandle semHandle, U32 timeout)
{
    uintptr_t intSave;
    U32 ret;
    struct TagTskCb *runTsk = NULL;
    struct TagSemCb *semPended = NULL;

    if (semHandle >= (SemHandle)g_maxSem) {
        return OS_ERRNO_SEM_INVALID;
    }

    semPended = GET_SEM(semHandle);

    intSave = OsIntLock();
    if (semPended->semStat == OS_SEM_UNUSED) {
        OsIntRestore(intSave);
        return OS_ERRNO_SEM_INVALID;
    }

    if (OS_INT_ACTIVE) {
        OsIntRestore(intSave);
        return OS_ERRNO_SEM_PEND_INTERR;
    }

    runTsk = (struct TagTskCb *)RUNNING_TASK;

    if (OsSemPendNotNeedSche(semPended, runTsk) == TRUE) {
        OsIntRestore(intSave);
        return OS_OK;
    }

    ret = OsSemPendParaCheck(timeout);
    if (ret != OS_OK) {
        OsIntRestore(intSave);
        return ret;
    }
    /* 把当前任务挂接在信号量链表上 */
    OsSemPendListPut(semPended, timeout);
    if (timeout != OS_WAIT_FOREVER) {
        OsIntRestore(intSave);
        return OS_ERRNO_SEM_FUNC_NOT_SUPPORT;
    } else {
        /* 恢复ps的快速切换 */
        OsTskScheduleFastPs(intSave);

    }

    OsIntRestore(intSave);
    return OS_OK;
}

OS_SEC_ALW_INLINE INLINE void OsSemPostSchePre(struct TagSemCb *semPosted)
{
    struct TagTskCb *resumedTask = NULL;

    resumedTask = OsSemPendListGet(semPosted);
    semPosted->semOwner = resumedTask->taskPid;
}

/*
* 描述：判断信号量post是否有效
* 备注：以下情况表示post无效，返回TRUE: post互斥二进制信号量，若该信号量被嵌套pend或者已处于空闲状态
*/
OS_SEC_ALW_INLINE INLINE bool OsSemPostIsInvalid(struct TagSemCb *semPosted)
{
    if (GET_SEM_TYPE(semPosted->semType) == SEM_TYPE_BIN) {
        /* 释放互斥二进制信号量且信号量已处于空闲状态 */
        if ((semPosted)->semCount == OS_SEM_FULL) {
            return TRUE;
        }
    }
    return FALSE;
}

/*
* 描述：指定信号量的V操作
*/
OS_SEC_L0_TEXT U32 PRT_SemPost(SemHandle semHandle)
{
    U32 ret;
    uintptr_t intSave;
    struct TagSemCb *semPosted = NULL;

    if (semHandle >= (SemHandle)g_maxSem) {
        return OS_ERRNO_SEM_INVALID;
    }

    semPosted = GET_SEM(semHandle);
    intSave = OsIntLock();

    ret = OsSemPostErrorCheck(semPosted, semHandle);
    if (ret != OS_OK) {
        OsIntRestore(intSave);
        return ret;
    }

    /* 信号量post无效，不需要调度 */
    if (OsSemPostIsInvalid(semPosted) == TRUE) {
        OsIntRestore(intSave);
        return OS_OK;
    }

    /* 如果有任务阻塞在信号量上，就激活信号量阻塞队列上的首个任务 */
    if (!ListEmpty(&semPosted->semList)) {
        OsSemPostSchePre(semPosted);
        /* 相当于快速切换+中断恢复 */
        OsTskScheduleFastPs(intSave);
    } else {
        semPosted->semCount++;
        semPosted->semOwner = OS_INVALID_OWNER_ID;

    }

    OsIntRestore(intSave);
    return OS_OK;
}
```

**src/include/prt_task_external.h 加入 OsTskReadyAddBgd()**

```c
OS_SEC_ALW_INLINE INLINE void OsTskReadyAddBgd(struct TagTskCb *task)
{
    OsTskReadyAdd(task);
}
```

**src/kernel/task/prt_task.c 加入 OsTskScheduleFastPs()**

```c
// src/core/kernel/task/prt_amp_task.c
/*
 * 描述：如果快速切换后只有中断恢复，使用此接口
 */
 OS_SEC_TEXT void OsTskScheduleFastPs(uintptr_t intSave)
 {
     /* Find the highest task */
     OsTskHighestSet();
 
    /* In case that running is not highest then reschedule */
    if ((g_highestTask != RUNNING_TASK) && (g_uniTaskLock == 0)) {
        UNI_FLAG |= OS_FLG_TSK_REQ;

    /* only if there is not HWI or TICK the trap */
        if (OS_INT_INACTIVE) {
            OsTaskTrapFastPs(intSave);
        }
    }
}
```

**src/bsp/os_cpu_armv8_external.h 加入 OsTaskTrapFastPs()**

```c
OS_SEC_ALW_INLINE INLINE void OsTaskTrapFastPs(uintptr_t intSave)
{
    (void)intSave;
    OsTaskTrap();
}
```

**加入 src/include/prt_sem.h，该头文件主要是信号量相关的函数声明和宏定义。**

```c
/*
 * Copyright (c) 2009-2022 Huawei Technologies Co., Ltd. All rights reserved.
 *
 * UniProton is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *          http://license.coscl.org.cn/MulanPSL2
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 * Create: 2009-12-22
 * Description: 信号量模块对外头文件。
 */
#ifndef PRT_SEM_H
#define PRT_SEM_H

#include "prt_module.h"
#include "prt_errno.h"

#ifdef __cplusplus
#if __cplusplus
extern "C" {
#endif
#endif /* __cplusplus */

/*
 * 信号量错误码：初始化信号量内存不足。
 *
 * 值: 0x02000701
 *
 * 解决方案: 可以将私有的静态内存空间配大。
 */
#define OS_ERRNO_SEM_NO_MEMORY OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x01)

/*
 * 信号量错误码：信号量句柄非法（错误或已删除）。
 *
 * 值: 0x02000702
 *
 * 解决方案: 查看输入的信号量句柄值是否有效。
 */
#define OS_ERRNO_SEM_INVALID OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x02)

/*
 * 信号量错误码：输入指针为空。
 *
 * 值: 0x02000703
 *
 * 解决方案: 查看指针是否输入为空。
 */
#define OS_ERRNO_SEM_PTR_NULL OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x03)

/*
 * 信号量错误码：没有空闲信号量。
 *
 * 值: 0x02000704
 *
 * 解决方案: 查看信号量模块是否打开，或配置更多信号量。
 */
#define OS_ERRNO_SEM_ALL_BUSY OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x04)

/*
 * 信号量错误码：信号量没有可用资源且Pend时设为不等待(等待时间为0)时获取信号量失败。
 *
 * 值: 0x02000705
 *
 * 解决方案: 无。
 */
#define OS_ERRNO_SEM_UNAVAILABLE OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x05)

/*
 * 信号量错误码：禁止中断处理函数阻塞于信号量。
 *
 * 值: 0x02000706
 *
 * 解决方案: 查看是否在中断中Pend信号量。
 */
#define OS_ERRNO_SEM_PEND_INTERR OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x06)

/*
 * 信号量错误码：任务切换锁定时，禁止任务阻塞于信号量。
 *
 * 值: 0x02000707
 *
 * 解决方案: 不要在锁任务时pend没有资源可用的信号量。
 */
#define OS_ERRNO_SEM_PEND_IN_LOCK OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x07)

/*
 * 信号量错误码：信号量等待超时。
 *
 * 值: 0x02000708
 *
 * 解决方案: 无。
 */
#define OS_ERRNO_SEM_TIMEOUT OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x08)

/*
 * 信号量错误码：信号量发生溢出。
 *
 * 值: 0x02000709
 *
 * 解决方案: 查看输入的信号量计数值是否有效。
 */
#define OS_ERRNO_SEM_OVERFLOW OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x09)

/*
 * 信号量错误码：信号量删除和重设当前值时有阻塞于信号量的任务。
 *
 * 值: 0x0200070a
 *
 * 解决方案: 如果当前信号量有任务阻塞，不能进行删除和重设计数值操作。
 */
#define OS_ERRNO_SEM_PENDED OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0a)

/*
 * 信号量错误码：注册核内信号量个数为0导致注册失败。
 *
 * 值: 0x0200070b
 *
 * 解决方案: 查看信号量模块配置的最大个数是否为0。
 */
#define OS_ERRNO_SEM_REG_ERROR OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0b)

/*
 * 信号量错误码：调用#PRT_SemGetPendList时，指定的内存空间不足，无法存入全部的阻塞任务PID。
 *
 * 值: 0x0200070c
 *
 * 解决方案: 建议将数组长度配置为(#OS_TSK_MAX_SUPPORT_NUM + 1) * 4。
 */
#define OS_ERRNO_SEM_INPUT_BUF_NOT_ENOUGH OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0c)

/*
 * 信号量错误码：调用#PRT_SemGetPendList时，输入指针为空或者bufLen小于4。
 *
 * 值: 0x0200070d
 *
 * 解决方案: 出参不能为NULL，指定的缓存长度不能小于4。
 */
#define OS_ERRNO_SEM_INPUT_ERROR OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0d)

/*
 * 信号量错误码：获取信号量详细信息时出参结构体指针为NULL。
 *
 * 值: 0x0200070e
 *
 * 解决方案: 用来保存信号量详细信息的结构体指针不能为NULL。
 */
#define OS_ERRNO_SEM_INFO_NULL OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0e)

/*
 * 信号量错误码：获取当前信号量计数时传入的出参为NULL。
 *
 * 值: 0x0200070f
 *
 * 解决方案: 互斥型信号量的唤醒方式不能为FIFO。
 */
#define OS_ERRNO_SEM_COUNT_GET_PTR_NULL OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x0f)

/*
 * 信号量错误码：非当前互斥信号量的持有者释放该信号量。
 *
 * 值: 0x02000710
 *
 * 解决方案: 互斥信号量只能由其持有者释放，即互斥信号量的PV操作必须配对使用。
 */
#define OS_ERRNO_SEM_MUTEX_NOT_OWNER_POST OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x10)

/*
 * 信号量错误码：在中断中释放互斥型信号量。
 *
 * 值: 0x02000711
 *
 * 解决方案: 只能在任务中对互斥型信号量进行PV操作。
 */
#define OS_ERRNO_SEM_MUTEX_POST_INTERR OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x11)

/*
 * 尚未实现该功能
 */
#define OS_ERRNO_SEM_FUNC_NOT_SUPPORT OS_ERRNO_BUILD_ERROR(OS_MID_SEM, 0x12)

/*
 * 信号量等待时间设定：表示不等待。
 */
#define OS_NO_WAIT 0

/*
 * 信号量等待时间设定：表示永久等待。
 */
#define OS_WAIT_FOREVER 0xFFFFFFFF

/*
 * 二进制信号量空闲状态，互斥型信号量初始计数值。
 */
#define OS_SEM_FULL  1

/*
 * 二进制信号量占用状态，同步型信号量初始计数值。
 */
#define OS_SEM_EMPTY 0

/*
 * 计数型信号量最大计数值。
 */
#define OS_SEM_COUNT_MAX 0xFFFFFFFE

/*
 * 信号量不被任何任务持有，处于空闲状态。
 */
#define OS_INVALID_OWNER_ID 0xFFFFFFFE

/*
 * 信号量句柄类型定义。
 */
typedef U16 SemHandle;

/*
 * 信号量类型。
 */
/* 计数型信号量 */
#define SEM_TYPE_COUNT 0
/* 二进制信号量 */
#define SEM_TYPE_BIN 1

/*
 * 信号量模块被阻塞线程唤醒方式。
 */
enum SemMode {
    SEM_MODE_FIFO,  // 信号量FIFO唤醒模式
    SEM_MODE_PRIOR, // 信号量优先级唤醒模式
    SEM_MODE_BUTT   // 信号量非法唤醒方式
};

/*
 * 信号量模块配置信息的结构体定义。
 */
struct SemModInfo {
    /* 最大支持的信号量数 */
    U16 maxNum;
    /* 保留 */
    U16 reserved;
};

/*
 * 信号量模块获取信号量详细信息时的信息结构体。
 */
struct SemInfo {
    /* 信号量计数 */
    U32 count;
    /* 信号量占用者，对于计数型信号量，记录的是最后一次信号量获得者；如果没有被任务获得，则为OS_THREAD_ID_INVALID */
    U32 owner;
    /* 信号量唤醒方式，为SEM_MODE_FIFO或SEM_MODE_PRIOR */
    enum SemMode mode;
    /* 信号量类型，为SEM_TYPE_COUNT（计数型）或SEM_TYPE_BIN（互斥型） */
    U32 type;
};

/*
 * @brief 创建一个计数型信号量。
 *
 * @par 描述
 * 根据用户指定的计数值，创建一个计数型信号量，设定初始计数器数值，唤醒方式为FIFO。
 * @attention
 * <ul><li>创建是否成功会受到"核内信号量裁剪开关"和"最大支持信号量"配置项的限制。</li></ul>
 *
 * @param count     [IN]  类型#U32，计数器初始值，取值范围为[0, 0xFFFFFFFE]。
 * @param semHandle [OUT] 类型#SemHandle *，输出信号量句柄。
 *
 * @retval #OS_OK  0x00000000，操作成功。
 * @retval #其它值，操作失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemDelete
 */
extern U32 PRT_SemCreate(U32 count, SemHandle *semHandle);

/*
 * @brief 删除一个信号量。
 *
 * @par 描述
 * 删除用户传入的信号量句柄指定的信号量，如果有任务阻塞于该信号量，则删除失败。
 * @attention  无
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 *
 * @retval #OS_OK  0x00000000，操作成功。
 * @retval #其它值，操作失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemCreate
 */
extern U32 PRT_SemDelete(SemHandle semHandle);

/*
 * @brief 获取信号量计数器数值。
 *
 * @par 描述
 * 根据用户输入信号量句柄和计数值，获取信号量计数器数值。
 * @attention 无
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 * @param semCnt    [OUT] 类型#U32 *，保存信号量计数值指针。
 *
 * @retval #OS_OK  0x00000000，获取信号量计数器值成功。
 * @retval #其它值，获取失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemCreate | PRT_SemGetInfo
 */
extern U32 PRT_SemGetCount(SemHandle semHandle, U32 *semCnt);

/*
 * @brief 等待一个信号量。
 *
 * @par 描述
 * 等待用户传入信号量句柄指定的信号量，若其计数器值大于0，则直接减1返回成功。否则任务阻塞，
 * 等待其他线程发布该信号量，等待超时时间可设定。
 * @attention
 * <ul>
 * <li>在osStart之前不能调用该接口。</li>
 * <li>等待时间可以选择零等待、等待特定时间、永久等待。</li>
 * <li>该接口只能被任务调用。</li>
 * <li>在锁任务情况下，用户要PEND信号量，要保证当前有可用信号量资源。</li>
 * </ul>
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 * @param timeout   [IN]  类型#U32，等待时间限制，单位为tick，取值范围为[0, 0xffffffff]。#OS_NO_WAIT或0表示不等待，
 * #OS_WAIT_FOREVER或0xffffffff表示永久等待。
 *
 * @retval #OS_OK  0x00000000，操作成功。
 * @retval #其它值，操作失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemPost
 */
extern U32 PRT_SemPend(SemHandle semHandle, U32 timeout);

/*
 * @brief 发布指定的信号量。
 *
 * @par 描述
 * 发布指定的信号量，若没有任务等待该信号量，则直接将计数器加1返回。
 * 否则根据唤醒方式唤醒相应的阻塞任务，FIFO方式唤醒最早阻塞的任务，优先级方式唤醒阻塞在此信号量的最高优先级任务。
 * @attention
 * <ul>
 * <li>在osStart之前不能调用该接口。</li>
 * <li>在未锁任务的情况下，如果唤醒的任务优先级高于当前任务，则会立刻发生任务切换。</li>
 * <li>发生任务切换时，如果支持优先级唤醒方式，且创建信号量时指定唤醒方式为优先级，
 * 则唤醒阻塞在该信号量上的最高优先级任务。</li>
 * </ul>
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 *
 * @retval #OS_OK  0x00000000，操作成功。
 * @retval #其它值，操作失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemPend
 */
extern U32 PRT_SemPost(SemHandle semHandle);

/*
 * @brief 获取阻塞在指定核内信号量上的任务PID清单。
 *
 * @par 描述
 * 根据用户指定的核内信号量句柄，获取阻塞在指定核内信号量上的任务PID清单。
 * 若有任务阻塞于该核内信号量，则返回阻塞于该核内信号量的任务数目，以及相应任务的PID。
 * 若没有任务阻塞于该核内信号量，则返回阻塞于该核内信号量的任务数目为0。
 * @attention
 * <ul><li>用户应保证存储任务PID清单的内存空间足够大，建议将bufLen配置为(#OS_TSK_MAX_SUPPORT_NUM + 1)
 * 4bytes。</li></ul>
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 * @param tskCnt    [OUT] 类型#U32 *，阻塞于该核内信号量的任务数。
 * @param pidBuf    [OUT] 类型#U32 *，由用户指定的内存区域首地址，用于存储阻塞于指定核内信号量的任务PID。
 * @param bufLen    [IN]  类型#U32，用户指定的内存区域的长度（单位：字节）。
 *
 * @retval #OS_OK  0x00000000，操作成功。
 * @retval #其它值，操作失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_TaskGetPendSem | PRT_SemGetInfo
 */
extern U32 PRT_SemGetPendList(SemHandle semHandle, U32 *tskCnt, U32 *pidBuf, U32 bufLen);

/*
 * @brief 获取信号量详细信息:信号量当前计数值，信号量持有者(最后一次pend成功的线程ID)，信号量唤醒方式，信号量类型。
 *
 * @par 描述
 * 根据用户输入信号量句柄获取信号量详细信息。
 * @attention 无
 *
 * @param semHandle [IN]  类型#SemHandle，信号量句柄，来源于信号量创建成功的输出值。
 * @param semInfo   [OUT] 类型#struct SemInfo *，信号量详细信息:count--信号量计数，owner--信号量占用者，
 * mode--信号量唤醒方式，type--信号量类型。
 *
 * @retval #OS_OK  0x00000000，获取信号量计数器值成功。
 * @retval #其它值，获取失败。
 * @par 依赖
 * <ul><li>prt_sem.h：该接口声明所在的头文件。</li></ul>
 * @see PRT_SemGetCount | PRT_SemGetPendList
 */
extern U32 PRT_SemGetInfo(SemHandle semHandle, struct SemInfo *semInfo);

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* __cplusplus */

#endif /* PRT_SEM_H */
```

> [!TIP]
>
> 将新增文件加入构建系统
>
> src/kernel/sem 目录下加入 CMakeLists.txt，src/ 和src/kernel下的CMakeLists.txt需修改
>
> src/kernel/sem/CMakeLists.txt 类似 src/bsp/CMakeLists.txt
>
> src/kernel/CMakeLists.txt 增加子目录： add_subdirectory(sem)
>
> src/CMakeLists.txt 需修改增加编译目标：`$<TARGET_OBJECTS:sem>`

## 验证

```c
#include "prt_typedef.h"
#include "prt_tick.h"
#include "prt_task.h"
#include "prt_sem.h"

extern U32 PRT_Printf(const char *format, ...);
extern void PRT_UartInit(void);
extern U32 OsActivate(void);
extern U32 OsTskInit(void);
extern U32 OsSemInit(void);


static SemHandle sem_sync;


void Test1TaskEntry()
{
    PRT_Printf("task 1 run ...\n");
    PRT_SemPost(sem_sync);
    U32 cnt = 5;
    while (cnt > 0) {
        // PRT_TaskDelay(200);
        PRT_Printf("task 1 run ...\n");
        cnt--;
    }
}

void Test2TaskEntry()
{
    PRT_Printf("task 2 run ...\n");

    PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
    U32 cnt = 5;
    while (cnt > 0) {
        // PRT_TaskDelay(100);
        PRT_Printf("task 2 run ...\n");
        cnt--;
    }
}

S32 main(void)
{
    // 任务模块初始化
    OsTskInit();
    OsSemInit(); // 参见demos/ascend310b/config/prt_config.c 系统初始化注册表

    PRT_UartInit();

 PRT_Printf("██████   ██████  ███              ███  ██████████            ████                        █████                █████   █████ ██████   █████ █████  █████\n");
    PRT_Printf("░██████ ██████  ░░░              ░░░   ░███░░░░░█            ░███                        ░███                 ░███    ░███  ░██████  ░███  ░███   ░███\n");
    PRT_Printf("░███░█████░███  ████  ████████   ████  ░███  █ ░  █████ ████ ░███   ██████  ████████     ░███████  █████ ████ ░███    ░███  ░███░███ ░███  ░███   ░███   ██████  ████████\n");
    PRT_Printf("░███░░███ ░███ ░░███ ░░███░░███ ░░███  ░██████   ░░███ ░███  ░███  ███░░███░░███░░███    ░███░░███░░███ ░███  ░███████████  ░███░░███░███  ░███   ░███  ███░░███░░███░░███\n");
    PRT_Printf("░███ ░░░  ░███  ░███  ░███ ░███  ░███  ░███░░█    ░███ ░███  ░███ ░███████  ░███ ░░░     ░███ ░███ ░███ ░███  ░███░░░░░███  ░███ ░░██████  ░███   ░███ ░███████  ░███ ░░░\n");
    PRT_Printf("░███      ░███  ░███  ░███ ░███  ░███  ░███ ░   █ ░███ ░███  ░███ ░███░░░   ░███         ░███ ░███ ░███ ░███  ░███    ░███  ░███  ░░█████  ░███   ░███ ░███░░░   ░███\n");
    PRT_Printf("█████     █████ █████ ████ █████ █████ ██████████ ░░████████ █████░░██████  █████        ████████  ░░███████  █████   █████ █████  ░░█████ ░░████████  ░░██████  █████\n");
    PRT_Printf("░░░░░     ░░░░░ ░░░░░ ░░░░ ░░░░░ ░░░░░ ░░░░░░░░░░   ░░░░░░░░ ░░░░░  ░░░░░░  ░░░░░        ░░░░░░░░    ░░░░░███ ░░░░░   ░░░░░ ░░░░░    ░░░░░   ░░░░░░░░    ░░░░░░  ░░░░░\n");
    PRT_Printf("                                                                                                    ███ ░███\n");
    PRT_Printf("                                                                                                   ░░██████\n");
    PRT_Printf("                                                                                                    ░░░░░░\n");

    PRT_Printf("ctr-a h: print help of qemu emulator. ctr-a x: quit emulator.\n\n");

    U32 ret;
    ret = PRT_SemCreate(0, &sem_sync);
    if (ret != OS_OK) {
        PRT_Printf("failed to create synchronization sem\n");
        return 1;
    }

    struct TskInitParam param = {0};

    // task 1
    // param.stackAddr = 0;
    param.taskEntry = (TskEntryFunc)Test1TaskEntry;
    param.taskPrio = 35;
    // param.name = "Test1Task";
    param.stackSize = 0x1000; //固定4096，参见prt_task_init.c的OsMemAllocAlign

    TskHandle tskHandle1;
    ret = PRT_TaskCreate(&tskHandle1, &param);
    if (ret) {
        return ret;
    }

    ret = PRT_TaskResume(tskHandle1);
    if (ret) {
        return ret;
    }

    // task 2
    // param.stackAddr = 0;
    param.taskEntry = (TskEntryFunc)Test2TaskEntry;
    param.taskPrio = 30;
    // param.name = "Test2Task";
    param.stackSize = 0x1000; //固定4096，参见prt_task_init.c的OsMemAllocAlign

    TskHandle tskHandle2;
    ret = PRT_TaskCreate(&tskHandle2, &param);
    if (ret) {
        return ret;
    }

    ret = PRT_TaskResume(tskHandle2);
    if (ret) {
        return ret;
    }

    // 启动调度
    OsActivate();

    // while(1);
    return 0;

}
```

## lab7 作业

### 作业1

各种并发问题模拟，至少3种。

#### 问题1：违反顺序缺陷

以经典的生产者/消费者问题为例，首先需要一个共享缓冲区buffer，定义两个函数put和get，分别让生产者放入数据，消费者取出数据。

```c
#define MAX 100
U32 buffer[MAX];
U32 fill = 0;
U32 use = 0;
U32 count = 0;
U32 loops = 5;
void put(U32 value) {
     buffer[fill] = value;
     fill = (fill + 1) % MAX;
     count++;
}
 
U32 get() {
    U32 tmp = buffer[use];
     use = (use + 1) % MAX;
     count--;
     return tmp;
}
```

因为线程运行顺序不能确定，如果消费者先运行，此时buffer为空，消费者会进入睡眠，

```c
void Test1TaskEntry()		//Producter
{
  PRT_Printf("task 1 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        put(i);
        PRT_Printf("task 1 put %d\n", i);
        PRT_SemPost(sem_sync);
    }
}

void Test2TaskEntry()		//Consumer
{
   PRT_Printf("task 2 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
       	PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        U32 tmp = get();
        PRT_SemPost(sem_sync);
        PRT_Printf("task 2 get %d\n", tmp);
    }
}
```

![截屏2024-06-01 下午4.54.15](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-06-01 下午4.54.15.png)

#### 解决方法

使用一个条件变量，让消费者和生产者在不满足条件变量的时候才睡眠

```c
void Test1TaskEntry()
{
  PRT_Printf("task 1 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 1) {
            PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        }
        put(i);
        PRT_Printf("task 1 put %d\n", i);
        PRT_SemPost(sem_sync);
    }
}

void Test2TaskEntry()
{
   PRT_Printf("task 2 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 0) {
            PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        }
        U32 tmp = get();
        PRT_SemPost(sem_sync);
        PRT_Printf("task 2 get %d\n", tmp);
    }
}
```

![截屏2024-06-01 下午4.57.26](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-06-01 下午4.57.26.png)

#### 问题2:单值缓冲区的生产者/消费者问题

以两个消费者和一个生产者的情况为例，将Task1作为生产者，Task2作为消费者，同时新增Task3作为生产者，但依然只使用一个信号量

```c
void Test1TaskEntry()       //Producter1
{
    PRT_Printf("task 1 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 1) {
            PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        }
        put(i);
        PRT_Printf("task 1 put %d\n", i);
        PRT_SemPost(sem_sync);
    }
}

void Test2TaskEntry()      //Consumer
{
    PRT_Printf("task 2 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 0) {
            PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        }
        U32 tmp = get();
        PRT_SemPost(sem_sync);
        PRT_Printf("task 2 get %d\n", tmp);
    }
}

void Test3TaskEntry()      //Consumer2
{
    PRT_Printf("task 3 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 0) {
            PRT_SemPend(sem_sync, OS_WAIT_FOREVER);
        }
        U32 tmp = get();
        PRT_SemPost(sem_sync);
        PRT_Printf("task 3 get %d\n", tmp);
    }
}
```

只使用一个信号量的问题在于如果消费者先运行，buffer为空，消费者先唤醒生产者p1，而这个生产者p1生产往后唤醒的不是消费者而是另一个生产者p2并睡眠，此时缓冲区已满p2也会睡眠，此时三个线程都会睡眠。

![截屏2024-06-01 下午4.33.54](/Users/fanglunlin/Library/Application Support/typora-user-images/截屏2024-06-01 下午4.33.54.png)

#### 解决方法：

使用两个信号量full,empty，分别用来唤醒生产者和消费者。

```c
static SemHandle empty, full;
void Test1TaskEntry()       //Producter1
{
    PRT_Printf("task 1 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 1) {
            PRT_SemPend(empty, OS_WAIT_FOREVER);
        }
        put(i);
        PRT_Printf("task 1 put %d\n", i);
        PRT_SemPost(full);
    }
}

void Test2TaskEntry()      //Consumer
{
    PRT_Printf("task 2 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 0) {
            PRT_SemPend(full, OS_WAIT_FOREVER);
        }
        U32 tmp = get();
        PRT_SemPost(empty);
        PRT_Printf("task 2 get %d\n", tmp);
    }
}

void Test3TaskEntry()      //Consumer2
{
    PRT_Printf("task 3 run\n");
    U32 i;
    for (i = 0; i < loops; i++)
    {
        while (count == 0) {
            PRT_SemPend(empty, OS_WAIT_FOREVER);
        }
        U32 tmp = get();
        PRT_SemPost(full);
        PRT_Printf("task 3 get %d\n", tmp);
    }
}
```

<img src="截屏2024-06-01 下午4.40.55.png" alt="截屏2024-06-01 下午4.40.55" style="zoom:80%;" />

#### 问题3：死锁

```c
static SemHandle L1, L2;
void Test1TaskEntry()
{
    PRT_Printf("task 1 run ...\n");
    PRT_Printf("task 1 try to get L2\n");
    PRT_SemPend(L2, OS_WAIT_FOREVER);
    PRT_Printf("task 1 get L2\n");
    PRT_Printf("task 1 try to get L1\n");
    PRT_SemPend(L1, OS_WAIT_FOREVER);
//    PRT_SemPost(sem_sync);
    PRT_SemPost(L2);
    PRT_Printf("task 1 release L2\n");
    PRT_SemPost(L1);
    PRT_Printf("task 1 release L1\n");
    U32 cnt = 5;
    while (cnt > 0) {
        // PRT_TaskDelay(200);
        PRT_Printf("task 1 run ...\n");
        cnt--;
    }
}

void Test2TaskEntry()
{
    PRT_Printf("task 2 run ...\n");
    PRT_Printf("task 2 try to get L1\n");
    PRT_SemPend(L1, OS_WAIT_FOREVER);
    PRT_Printf("task 2 get L1\n");
    PRT_Printf("now task 2 switch to task 1\n");
    PRT_SemPend(sem_sync, OS_WAIT_FOREVER);         //模拟上下文切换
    PRT_SemPend(L2, OS_WAIT_FOREVER);
    PRT_SemPost(L1);
    PRT_Printf("task 2 release L1\n");
    PRT_SemPost(L2);
    PRT_Printf("task 2 release L2\n");
    U32 cnt = 5;
    while (cnt > 0) {
        // PRT_TaskDelay(100);
        PRT_Printf("task 2 run ...\n");
        cnt--;
    }
}
```

<img src="截屏2024-06-01 下午5.20.59.png" alt="截屏2024-06-01 下午5.20.59" style="zoom:67%;" />

#### 解决方法

通过原子地抢锁来避免，可以新增一个锁prevention，

```
 lock(prevention); 
 lock(L1); 
 lock(L2); 
 ... 
 unlock(prevention);
```

先抢到 prevention 这个锁之后，代码保证了在抢锁的过程中，不会有不合时宜的线程切换，从而避免了死锁。

## 实验体会

通过本次实验，我对信号量在操作系统中的作用和实现有了更深入的理解。信号量作为一种同步机制，能够有效地协调多个任务之间的并发操作，防止资源竞争和死锁问题。在实现过程中，特别是在初始化和创建信号量时，我学会了如何管理信号量的状态和控制块。此外，通过编写和调试任务同步的代码，我掌握了如何利用信号量进行任务间的互斥与同步操作，增强了我对操作系统底层机制的认知和编程能力。这些经验为我今后处理更复杂的并发问题打下了坚实的基础。

## 出现的问题

主要的问题还是出现在作业上，由于这个实验的调度点无法像线程一样随机切换，所以在构造出能够正确反应并发问题的代码时花费了比较多的时间。其余的思路都和书上差不多，是一个很好的复习机会。