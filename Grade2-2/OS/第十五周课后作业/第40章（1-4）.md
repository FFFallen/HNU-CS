# 第40章（1-4）

使用工具 vsfs.py 来研究文件系统状态如何随着各种操作的发生而改变。文件系统以空状态开始，只有一个根目录。模拟发生时会执行各种操作，从而慢慢改变文件系统的磁盘状态。详情请参阅 README 文件

## Q1

用一些不同的随机种子（比如 17、18、19、20）运行模拟器，看看你是否能确定每次状态变化之间一定发生了哪些操作。

### Seed 17

<img src="截屏2024-06-13 下午8.23.51.png" alt="截屏2024-06-13 下午8.23.51" style="zoom: 50%;" /><img src="截屏2024-06-13 下午8.24.38.png" alt="截屏2024-06-13 下午8.24.38" style="zoom:50%;" />

可以看到运行时初始根目录内有两个文件目录`.` 和`..`且它们的inumber都是0，即根目录的inode number，因为根目录的当前目录和父目录都是自身

接下来对文件系统进行一系列操作

第一个操作后文件系统状态为

```sh
inode bitmap  11000000
inodes       [d a:0 r:3][d a:1 r:2][][][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (u,1)][(.,1) (..,0)][][][][][][]
```

通过inode bitmap和indoes可知这一步操作在根目录下创建了一个direction（根目录的reference count+1），为其分配的data块序号为1，通过data bitmap和data块内容可以看到确实在了根目录下创建了一个名为u的目录，其inumber也能对应到inodes，且1号data块中保存了一个目录默认拥有的两个文件目录，所以这一步操作为

`mkdir("/u")`

第二个操作后文件系统状态为

```sh
inode bitmap  11100000
inodes       [d a:0 r:3][d a:1 r:2][f a:-1 r:1][][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (u,1) (a,2)][(.,1) (..,0)][][][][][][]
```

通过inode bitmap和indoes可知这一步操作创建了一个file，且该文件为空，没有为其分配data块（a: -1 r: 1），查看data可发现它在根目录下，文件名为a，inumber也能对应到它在inodes的位置，所以这一步操作为

`create("/a")`

第三个操作后文件系统状态为

```sh
inode bitmap  11000000
inodes       [d a:0 r:3][d a:1 r:2][][][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (u,1)][(.,1) (..,0)][][][][][][]
```

通过inode bitmap和indoes可知这一步操作将第二步操作创建的文件a删除了，查看data可发现文件a已不在根目录下，所以这一步操为

`unlink("/a")`

第四个操作后文件系统状态为

```sh
inode bitmap  11100000
inodes       [d a:0 r:4][d a:1 r:2][d a:2 r:2][][][][][]
data bitmap   11100000
data         [(.,0) (..,0) (u,1) (z,2)][(.,1) (..,0)][(.,2) (..,0)][][][][][]
```

通过inode bitmap和indoes可知这一步操作在根目录下创建了一个direction（根目录的reference count+1），为其分配的data块序号为2，通过data bitmap和data块内容可以看到根目录下创建了一个名为z的目录，2号data块也有了内容，所以这一步操作为

`mkdir("/z")`

第五个操作后文件系统状态为

```sh
inode bitmap  11110000
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][][][][]
data bitmap   11110000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0)][(.,2) (..,0)][(.,3) (..,0)][][][][]
```

通过inode bitmap和indoes可知这一步操作在根目录下创建了一个direction（根目录的reference count+1），为其分配的data块序号为3，通过data bitmap和data块内容可以看到根目录下创建了一个名为s的目录，3号data块内是其默认拥有的两个文件目录，所以这一步操作为

`mkdir("/s")`

第六个操作后文件系统状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][f a:-1 r:1][][][]
data bitmap   11110000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0)][(.,2) (..,0) (x,4)][(.,3) (..,0)][][][][]
```

通过inode bitmap和indoes可知这一步操作创建了一个file，且该文件为空，没有为其分配data块，查看data可发现它在目录z下，文件名为x，inumber也能对应到它在inodes的位置，所以这一步操作为

`creat("/z/x")`

第七个操作后文件系统状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][f a:-1 r:2][][][]
data bitmap   11110000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0) (b,4)][(.,2) (..,0) (x,4)][(.,3) (..,0)][][][][]
```

通过inode bitmap和indoes可知这一步操作创建了一个到文件x的hard link（文件x的reference count+1），在data中查看此硬链接在目录u下，名为b，所以这一步操作是

`link("/z/x", "/u/b")`

第八个操作后文件系统状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][f a:-1 r:1][][][]
data bitmap   11110000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0)][(.,2) (..,0) (x,4)][(.,3) (..,0)][][][][]
```

inode bitmap和indoes都没有变化，在data中可发现上一步的硬链接/u/b被移除，说明链接被取消，所以这一步操作为

`unlink("/u/b")`

第九个操作后文件系统状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][f a:4 r:1][][][]
data bitmap   11111000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0)][(.,2) (..,0) (x,4)][(.,3) (..,0)][v][][][]
```

通过inodes发现分配了一个data bolck给文件x，该block的序号为4，在data中查看，发现4号bolck中新增了内容v，即文件x中的内容，所以这一步操作为

`fd=open("/z/x", O_WRONLY|O_APPEND); write(fd,, buf, BLOCKSIZE); close(fd)`

第十个操作后文件系统状态为

```sh
inode bitmap  11111100
inodes       [d a:0 r:5][d a:1 r:2][d a:2 r:2][d a:3 r:2][f a:4 r:1][f a:-1 r:1][][]
data bitmap   11111000
data         [(.,0) (..,0) (u,1) (z,2) (s,3)][(.,1) (..,0) (b,5)][(.,2) (..,0) (x,4)][(.,3) (..,0)][v][][][]
```

通过inode bitmap和indoes可知这一步操作创建了一个file，且该文件为空文件，没有为其分配data块，查看data可发现它在目录u下，文件名为b，所以这一步操作为

`creat("/u/b")`

使用-c标志查看答案：

<img src="截屏2024-06-14 上午9.17.41.png" alt="截屏2024-06-14 上午9.17.41" style="zoom:50%;" /><img src="截屏2024-06-14 上午9.18.02.png" alt="截屏2024-06-14 上午9.18.02" style="zoom:50%;" />

其他种子分析方法类似

### Seed 20

<img src="截屏2024-06-14 上午9.20.05.png" alt="截屏2024-06-14 上午9.20.05" style="zoom:50%;" /><img src="截屏2024-06-14 上午9.20.45.png" alt="截屏2024-06-14 上午9.20.45" style="zoom:50%;" />

## Q2

现在使用不同的随机种子（比如 21、22、23、24），但使用 -r 标志运行，这样做可以让你在显示操作时猜测状态的变化。关于 inode 和数据块分配算法，根据它们喜欢分配的块，你可以得出什么结论？

### Seed 21

<img src="截屏2024-06-14 上午9.23.40.png" alt="截屏2024-06-14 上午9.23.40" style="zoom:50%;" />

第一步操作为`mkdir("/o")`，这一步操作是在根目录下创建了名为o的目录，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11000000
inodes       [d a:0 r:3][d a:1 r:2][][][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (o,1)][(.,1) (..,0)][][][][][][]
```

第二步操作为`creat("/b")`，即在根目录下创建名为b的文件，默认创建的是空文件，不为其分配data bolck，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11100000
inodes       [d a:0 r:3][d a:1 r:2][f a:-1 r:1][][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (o,1) (b,2)][(.,1) (..,0)][][][][][][]
```

第三步操作为`creat("/o/q")`，即在目录o下创建名为q的文件，默认创建的文件是空文件，不为其分配data bolck，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11110000
inodes       [d a:0 r:3][d a:1 r:2][f a:-1 r:1][f a:-1 r:1][][][][]
data bitmap   11000000
data         [(.,0) (..,0) (o,1) (b,2)][(.,1) (..,0) (q,3)][][][][][][]
```

第四步操作为`fd=open("/b", O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd)`，即用系统调用open打开根目录下的文件b，并使用write系统调用为它分配一个数据块并写入，最后关闭该文件，所以这一步操作后文件系统的状态为(**内容是不确定的**)

```sh
inode bitmap  11110000
inodes       [d a:0 r:3][d a:1 r:2][f a:2 r:1][f a:-1 r:1][][][][]
data bitmap   11100000
data         [(.,0) (..,0) (o,1) (b,2)][(.,1) (..,0) (q,3)][m][][][][][]
```

第五步操作为`fd=open("/o/q", O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd)`，即用系统调用open打开目录o下的文件q，并使用write系统调用为它分配一个数据块并写入，最后关闭该文件，所以这一步操作后文件系统的状态为(**内容是不确定的**)

```sh
inode bitmap  11110000
inodes       [d a:0 r:3][d a:1 r:2][f a:2 r:1][f a:3 r:1][][][][]
data bitmap   11110000
data         [(.,0) (..,0) (o,1) (b,2)][(.,1) (..,0) (q,3)][m][j][][][][]
```

第五步操作为`creat("/o/j")`，即在目录o下创建名为j的文件，默认创建的文件是空文件，不为其分配data bolck，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:3][d a:1 r:2][f a:2 r:1][f a:3 r:1][f a:-1 r:1][][][]
data bitmap   11110000
data         [(.,0) (..,0) (o,1) (b,2)][(.,1) (..,0) (q,3) (j,4)][m][j][][][][]
```

第六步操作为`unlink("/b")`，即调用 unlink()删除根目录下可读的文件名b与给定inode 号之间的硬链接，并减少引用计数。此时引用计数减为0，文件b被删除，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11011000
inodes       [d a:0 r:3][d a:1 r:2][][f a:3 r:1][f a:-1 r:1][][][]
data bitmap   11010000
data         [(.,0) (..,0) (o,1)][(.,1) (..,0) (q,3) (j,4)][][j][][][][]
```

第七步操作为`fd=open("/o/j", O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd)`，即用系统调用open打开目录o下的文件j，并使用write系统调用为它分配一个数据块并写入，选择的数据块是便利data找到第一个空闲块即上一步删除的后得到的，最后关闭该文件，所以这一步操作后文件系统的状态为(**内容是不确定的**)

```sh
inode bitmap  11011000
inodes       [d a:0 r:3][d a:1 r:2][][f a:3 r:1][f a:2 r:1][][][]
data bitmap   11110000
data         [(.,0) (..,0) (o,1)][(.,1) (..,0) (q,3) (j,4)][g][j][][][]
```

第八步操作为`creat("/o/x")`，即在目录o下创建名为x的文件，默认创建的是空文件，不为其分配data bolck，其信息存放到第2号inode。所以这一步操作后文件系统的状态为

```sh
inode bitmap  11111000
inodes       [d a:0 r:3][d a:1 r:2][f a:-1 r:1][f a:3 r:1][f a:2 r:1][][][]
data bitmap   11110000
data         [(.,0) (..,0) (o,1)][(.,1) (..,0) (q,3) (j,4) (x,2)][g][j][][][][]
```

第九步操作为`mkdir("/o/t")`，这一步操作是在目录o下创建名为t的目录，其信息存放到第6号inode，为其分配data块为4号块，所以这一步操作后文件系统的状态为

```sh
inode bitmap  11111100
inodes       [d a:0 r:3][d a:1 r:3][f a:-1 r:1][f a:3 r:1][f a:2 r:1][d a:4 r:2][][]
data bitmap   11111000
data         [(.,0) (..,0) (o,1)][(.,1) (..,0) (q,2) (j,3) (o,4) (x,2) (t,5)][g][j][(.,5) (..,1)][][][]
```

使用-c标志查看答案

<img src="截屏2024-06-14 下午3.08.23.png" alt="截屏2024-06-14 下午3.08.23" style="zoom:50%;" /><img src="截屏2024-06-14 下午3.07.46.png" alt="截屏2024-06-14 下午3.07.46" style="zoom:50%;" />

其他种子分析方法类似

### Seed 22

<img src="截屏2024-06-14 下午3.13.44.png" alt="截屏2024-06-14 下午3.13.44" style="zoom:50%;" /><img src="截屏2024-06-14 下午3.14.01.png" alt="截屏2024-06-14 下午3.14.01" style="zoom:50%;" />

### Seed 23

<img src="截屏2024-06-14 下午3.15.07.png" alt="截屏2024-06-14 下午3.15.07" style="zoom:50%;" /><img src="截屏2024-06-14 下午3.15.29.png" alt="截屏2024-06-14 下午3.15.29" style="zoom:50%;" />

### Seed 24

<img src="截屏2024-06-14 下午3.10.51.png" alt="截屏2024-06-14 下午3.10.51" style="zoom:50%;" /><img src="截屏2024-06-14 下午3.10.14.png" alt="截屏2024-06-14 下午3.10.14" style="zoom:50%;" />

通过观察5个种子的运行结果，该vsfs的 inode 和数据块分配算法是遍历inodes和data使用最近可分配 inode 与数据块

## Q3

现在将文件系统中的数据块数量减少到非常少（比如两个），并用 100 个左右的请求来运行模拟器。在这种高度约束的布局中，哪些类型的文件最终会出现在文件系统中？ 什么类型的操作会失败？

运行参数设置

```sh
./vsfs.py -d 2 -n 100 -c
```

### Seed 0

<img src="截屏2024-06-14 下午3.56.38.png" alt="截屏2024-06-14 下午3.56.38" style="zoom:50%;" />

### Seed 1

<img src="截屏2024-06-14 下午3.57.18.png" alt="截屏2024-06-14 下午3.57.18" style="zoom:50%;" />

### Seed 2

<img src="截屏2024-06-14 下午3.57.38.png" alt="截屏2024-06-14 下午3.57.38" style="zoom:50%;" />

### Seed 3

<img src="截屏2024-06-14 下午3.58.04.png" alt="截屏2024-06-14 下午3.58.04" style="zoom:50%;" />

### Seed 100

<img src="截屏2024-06-14 下午4.02.25.png" alt="截屏2024-06-14 下午4.02.25" style="zoom:50%;" />

通过使用5个种子运行来看，vsfs不会去使用最后一块数据块，只使用第0块数据块，该数据块已分配给根目录，所以当创建新的目录或给空文件分配数据块时操作都会失败，所以最终出现在文件系统中的文件类型只有根目录或者空文件，会分配数据块的操作都会失败，如：mkdir()、open(), write(), close()，而create()和link()、unlink()不会

## Q4

现在做同样的事情，但针对 inodes。只有非常少的 inode，什么类型的操作才能成功？ 哪些通常会失败？文件系统的最终状态可能是什么？

运行参数设置

```sh
./vsfs.py -i 3 -n 100 -c
```

### Seed 0

<img src="截屏2024-06-14 下午4.19.59.png" alt="截屏2024-06-14 下午4.19.59" style="zoom:50%;" />

### Seed 1

<img src="截屏2024-06-14 下午4.20.20.png" alt="截屏2024-06-14 下午4.20.20" style="zoom:50%;" />

### Seed 2

<img src="截屏2024-06-14 下午4.20.45.png" alt="截屏2024-06-14 下午4.20.45" style="zoom:50%;" />

### Seed 3

<img src="截屏2024-06-14 下午4.21.07.png" alt="截屏2024-06-14 下午4.21.07" style="zoom:50%;" />

运行4个不同的种子可以发现vsfs也不会使用最后一个inode，所以当已经使用了两个inode后，在执行需要使用新inode的操作都会失败，如:mkdir()、creat()、link()，而不使用inode或删除文件的操作一般会成功，如：open(), write(), close()、unlik()，文件系统的最终状态是文件系统中有一个根目录以及另一个目录或文件。