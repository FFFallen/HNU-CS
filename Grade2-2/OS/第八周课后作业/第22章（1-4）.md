# 第22章（1-4）

## 1．使用以下参数生成随机地址：-s 0 -n 10，-s 1 -n 10 和-s 2 -n 10。将策略从 FIFO 更改为 LRU，并将其更改为 OPT。计算所述地址追踪中的每个访问是否命中或未命中。

### 种子0（使用FIFO策略）：

<img src="截屏2024-05-05 下午4.33.24.png" alt="截屏2024-05-05 下午4.33.24" style="zoom:67%;" />

根据生成的参数可知缓存大小为3

Access: 8 MISS FI->				           [8]<-LI	Replace:- [Hits:0 Misses:1]

Access: 7 MISS FI->			      	[8, 7]<-LI	Replace:- [Hits:0 Misses:2]

Access: 4  MISS FI->			 	[8, 7, 4]<-LI	Replace:- [Hits:0 Misses:3]

Access: 2 MISS FI->			  	[7, 4, 2]<-LI	Replace:8 [Hits:0 Misses:4]

Access: 5 MISS FI->				  [4, 2, 5]<-LI	Replace:7 [Hits:1 Misses:5]

Access: 4 MISS FI->				  [4, 2, 5]<-LI	Replace:- [Hits:2 Misses:5]

Access: 7 MISS FI->				  [2, 5, 7]<-LI	Replace:4 [Hits:2 Misses:6]

Access: 3 MISS FI->				  [5, 7, 3]<-LI	Replace:2 [Hits:2 Misses:7] 

Access: 4 MISS FI->				  [7, 3, 4]<-LI	Replace:5 [Hits:0 Misses:8] 

Access: 5 MISS FI->				  [3, 4, 5]<-LI	Replace:7 [Hits:0 Misses:9] 

### 种子1（使用LRU策略）：

<img src="截屏2024-05-05 下午4.49.41.png" alt="截屏2024-05-05 下午4.49.41" style="zoom:67%;" />

根据生成的参数可知缓存大小为3

Access: 1 MISS LRU ->     		     [1] <- MRU 	Replaced:- [Hits:0 Misses:1]

Access: 8 MISS LRU ->    		  [1, 8] <- MRU 	Replaced:- [Hits:0 Misses:2]

Access: 7 MISS LRU ->  		[1, 8, 7] <- MRU 	Replaced:- [Hits:0 Misses:3]

Access: 2 MISS LRU ->  		[8, 7, 2] <- MRU 	Replaced:1 [Hits:0 Misses:4]

Access: 4 MISS LRU ->  		[7, 2, 4] <- MRU 	Replaced:8 [Hits:0 Misses:5]

Access: 4 HIT    LRU ->  		[7, 2, 4] <- MRU 	Replaced:- [Hits:1 Misses:5]

Access: 6 MISS LRU ->  		[2, 4, 6] <- MRU 	Replaced:7 [Hits:1 Misses:6]

Access: 7 MISS LRU ->  		[4, 6, 7] <- MRU 	Replaced:2 [Hits:1 Misses:7]

Access: 0 MISS LRU ->  		[6, 7, 0] <- MRU 	Replaced:4 [Hits:1 Misses:8]

Access: 0 HIT    LRU ->  		[6, 7, 0] <- MRU 	Replaced:- [Hits:2 Misses:8]

### 种子2（使用OPT策略）：

<img src="截屏2024-05-05 下午4.53.59.png" alt="截屏2024-05-05 下午4.53.59" style="zoom:67%;" />

根据生成的参数可知缓存大小为3

Access: 9 MISS Left ->			[9] <- Right 	Replaced:- [Hits:0 Misses:1]

Access: 9 HIT    Left ->			[9] <- Right 	Replaced:- [Hits:1 Misses:1]

Access: 0 MISS Left ->	    	[9, 0] <- Right 	Replaced:- [Hits:1 Misses:2]

Access: 0 HIT    Left ->		    [9, 0] <- Right 	Replaced:- [Hits:2 Misses:2]

Access: 8 MISS Left ->		[9, 0, 8] <- Right 	Replaced:- [Hits:2 Misses:3]

Access: 7 MISS Left ->		[9, 0, 7] <- Right	 Replaced:8 [Hits:2 Misses:4]

Access: 6 MISS Left ->		[9, 0, 6] <- Right 	Replaced:7 [Hits:2 Misses:5]

Access: 3 MISS Left ->		[3, 0, 6] <- Right 	Replaced:9 [Hits:2 Misses:6]

Access: 6 HIT    Left ->		[3, 0, 6] <- Right 	Replaced:- [Hits:3 Misses:6]

Access: 6 HIT    Left ->		[3, 0, 6] <- Right 	Replaced:- [Hits:4 Misses:6]

## 2．对于大小为 5 的高速缓存，为以下每个策略生成最差情况的地址引用序列：FIFO、LRU 和 MRU（最差情况下的引用序列导致尽可能多的未命中）。对于最差情况下的引用序列，需要的缓存增大多少，才能大幅提高性能，并接近 OPT？

```shell
./paging-policy.py -a 1,2,3,4,5,6,1,2,3 -C 5 -p FIFO   
```

```shell
./paging-policy.py -a 1,2,3,4,5,6,1,2,3 -C 5 -p LRU
```

```sh
./paging-policy.py -a 1,2,3,4,5,6,5,6,5 -C 5 -p MRU
```

对于对于最差情况下的引用序列，需要的缓存增大为和地址数相同，才能大幅提高性能，并接近 OPT。

## 3．生成一个随机追踪序列（使用 Python 或 Perl）。你预计不同的策略在这样的追踪序列上的表现如何？

使用Python生成随机序列：

```python
import random as rd
addrs = []
addr_num = 20
for i in range(0, addr_num):
    address = rd.randint(1,8)
    addrs.append(address)
file = open("/Users/fanglunlin/Documents/ostep-homework-master/vm-beyondphys-policy/list.txt", "w")
for i in addrs:
    file.write(str(i)+"\n")
file.close()
```

生成的随机序列：

1 6 5 8 8 5 5 1 1 4 6 2 5 8 3 4 8 4 2 8

预测该序列在OPT策略下表现最优，其次是LRU、CLOCK、RAND、FIFO、UNOPT

### FIFO:

<img src="截屏2024-05-05 下午6.00.18.png" alt="截屏2024-05-05 下午6.00.18" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.00.56.png" alt="截屏2024-05-05 下午6.00.56" style="zoom:67%;" />

### LRU:

<img src="截屏2024-05-05 下午6.02.42.png" alt="截屏2024-05-05 下午6.02.42" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.01.35.png" alt="截屏2024-05-05 下午6.01.35" style="zoom:67%;" />

### OPT:

<img src="截屏2024-05-05 下午6.04.09.png" alt="截屏2024-05-05 下午6.04.09" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.02.18.png" alt="截屏2024-05-05 下午6.02.18" style="zoom:67%;" />

### UNOPT:

<img src="截屏2024-05-05 下午6.04.49.png" alt="截屏2024-05-05 下午6.04.49" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.02.07.png" alt="截屏2024-05-05 下午6.02.07" style="zoom:67%;" />

### RAND:

<img src="截屏2024-05-05 下午6.05.15.png" alt="截屏2024-05-05 下午6.05.15" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.06.05.png" alt="截屏2024-05-05 下午6.06.05" style="zoom:67%;" />

### CLOCK:

<img src="截屏2024-05-05 下午6.05.33.png" alt="截屏2024-05-05 下午6.05.33" style="zoom:67%;" /><img src="截屏2024-05-05 下午6.06.34.png" alt="截屏2024-05-05 下午6.06.34" style="zoom:67%;" />

根据运行结果来看，各策略的表现如下：

| 策略  | 命中率 |
| :---: | :----: |
|  OPT  | 55.00% |
| RAND  | 40.00% |
|  LRU  | 35.00% |
| CLOCK | 35.00% |
| FIFO  | 30.00% |
| UNOPT | 15.00% |

可以看到RAND策略表现比其他序列好，这是RAND策略的特性，它的命中率可以像OPT策略一样好

### 4．现在生成一些局部性追踪序列。如何能够产生这样的追踪序列？LRU 表现如何？RAND比 LRU 好多少？CLOCK 表现如何？CLOCK 使用不同数量的时钟位，表现如何？

##### 生成空间局部性序列：

```python
import random as rd
addr_num = 20
addrs = [rd.randint(1, 8)]
r = addrs[0]
for i in range(0, addr_num):
    address = [r, r + 1, r - 1, rd.randint(1, 8)]
    addrs.append(rd.choice(address))
file = open("/Users/fanglunlin/Documents/ostep-homework-master/vm-beyondphys-policy/list1.txt", "w")
for i in addrs:
    file.write(str(i)+"\n")
file.close()
```

3 3 7 2 2 4 8 4 2 6 6 3 8 2 4 2 3 3 3 2 2

### OPT:

<img src="截屏2024-05-05 下午6.49.11.png" alt="截屏2024-05-05 下午6.49.11" style="zoom:67%;" />

### LRU:

<img src="截屏2024-05-05 下午6.39.25.png" alt="截屏2024-05-05 下午6.39.25" style="zoom:67%;" />

### RAND:

<img src="截屏2024-05-05 下午6.40.02.png" alt="截屏2024-05-05 下午6.40.02" style="zoom:67%;" />

### CLOCK:

<img src="截屏2024-05-05 下午6.40.34.png" alt="截屏2024-05-05 下午6.40.34" style="zoom:67%;" />

#### 生成时间局部性序列：

```python
import random as rd
addr_num = 20
addrs = [rd.randint(1, 8)]
r = addrs[0]
for i in range(0, addr_num):
    address = [rd.choice(addrs), rd.randint(1, 8)]
    addrs.append(rd.choice(address))
file = open("/Users/fanglunlin/Documents/ostep-homework-master/vm-beyondphys-policy/list2.txt", "w")
for i in addrs:
    file.write(str(i)+"\n")
file.close()
```

4 4 4 2 4 6 6 3 6 3 2 6 2 2 4 4 4 4 4 4 4

### OPT:

<img src="截屏2024-05-05 下午6.48.16.png" alt="截屏2024-05-05 下午6.48.16" style="zoom:67%;" />LRU:

<img src="截屏2024-05-05 下午6.45.16.png" alt="截屏2024-05-05 下午6.45.16" style="zoom:67%;" />

### RAND:

<img src="截屏2024-05-05 下午6.45.32.png" alt="截屏2024-05-05 下午6.45.32" style="zoom:67%;" />

### CLOCK:

<img src="截屏2024-05-05 下午6.45.44.png" alt="截屏2024-05-05 下午6.45.44" style="zoom:67%;" />

根据运行结果来看，各策略表现如下

| 策略  | 空间局部性 | 时间局部性 |
| ----- | ---------- | ---------- |
| OPT   | 61.90%     | 76.19%     |
| LRU   | 47.62%     | 71.43%     |
| RAND  | 38.10%     | 61.90%     |
| CLOCK | 52.38%     | 71.43%     |

可以发现，在序列空间局部性较好时LRU的表现一般，RAND不一定比LRU好，CLOCK在使用3个时钟位时表现接近OPT，在序列的时间局部性好时，LRU表现最接近OPT，RAND也不一定比LRU好，CLOCK和LRU表现一样。

#### COCLK使用不同数量的时钟位：

| 时钟位 | 空间局部性序列命中率 | 时间局部性序列命中率 |
| ------ | -------------------- | -------------------- |
| 1      | 42.86%               | 66.67%               |
| 2      | 52.38%               | 71.43%               |
| 3      | 52.38%               | 71.43%               |
| 4      | 52.38%               | 71.43%               |
| 5      | 52.38%               | 71.43%               |
| 6      | 52.38%               | 71.43%               |
| 7      | 52.38%               | 71.43%               |
| 8      | 52.38%               | 71.43%               |
| 9      | 52.38%               | 71.43%               |
| 10     | 52.38%               | 71.43%               |

可以观察到，随着时钟位的增加，CLOCK策略的效果应该会逐步提升。但超过一定范围就效果不会发生改变。