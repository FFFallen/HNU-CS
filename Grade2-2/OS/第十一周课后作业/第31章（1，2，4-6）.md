# 第31章（1，2，4-6）

## Q1

第一个问题只是实现和测试 fork/join问题的解决方案，如文本中所述。尽管文本中描述了这个解决方案，但自己输入它是值得的；甚至巴赫也会重写维瓦尔第，让一个即将成为大师的大师向现有的大师学习。详情请参阅fork-join.c。将sleep(1)调用添加到child函数中，以确保它正常工作。

题目要求我们修改fork-join.c，使它能成功编译并运行：

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include "common_threads.h"
#include <semaphore.h>
sem_t* s;

void *child(void *arg) {
    sleep(1);
    printf("child\n");
    // use semaphore here
    sem_post(s);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    printf("parent: begin\n");
    // init semaphore here
   	sem_unlink("mysem");
    s = sem_open("mysem", O_CREAT | O_EXCL, NULL, 0);
    pthread_create(&p, NULL, child, NULL);
    // use semaphore here
    sem_wait(s);
    sem_unlink("mysem");
    printf("parent: end\n");
    return 0;
}

```

我是用的电脑系统为MacOS，在Mac OS X的C语言编程中不允许创建无名信号量，sem_init函数已被弃用，需要使用sem_open创建有名信号量，并且POSIX 线程库中只有pthread_create函数，C 预处理器（如宏定义）通常对大小写不敏感，但函数调用是区分大小写的，需把Pthread_create修改成pthread_create。

> [!NOTE]
>
> sem_open函数原型
>
> `sem_t *sem_open(const char *name, int oflag, ...);`
>
> 参数说明：
>
> 1. `name`：这是信号量的名称，它在系统范围内应该是唯一的。命名信号量允许不同的进程通过名称来访问同一个信号量。
> 2. `oflag`：这是一个或多个标志的组合，用于指定对信号量的操作。常用的标志有：
>    - `O_CREAT`：如果信号量不存在，则创建它。
>    - `O_EXCL`：与 `O_CREAT` 一起使用，如果信号量已经存在，则 `sem_open` 调用失败。这用于避免创建已经存在的信号量。
>    - 其他标志可能包括访问权限位，但在 Mac OS X 中，这些权限位通常被忽略。
> 3. 省略号（`...`）：这是一个可选参数，用于传递额外的信息，如信号量的初始值和权限。如果 `oflag` 包含 `O_CREAT`，则至少需要传递两个额外的参数：
>    - 模式（mode_t）：类似于文件的权限，指定了信号量的访问权限。
>    - 初始值（unsigned int）：信号量的初始值。
>
> 返回值：
>
> - 成功时，`sem_open` 返回指向信号量的指针。
> - 失败时，返回 `SEM_FAILED`，一个宏定义的空指针。

最终将代码修改成以上代码后使用gcc -o fork-join fork-join.c -Wall -pthread编译后运行，运行结果如下，可以看到创建的线程执行饿了child函数代码，调用sleep函数后睡眠了1秒，再打印出"child"，发送信号量唤醒父进程打印"parent: end"。

<img src="截屏2024-06-03 上午11.21.08.png" alt="截屏2024-06-03 上午11.21.08" style="zoom:67%;" />

## Q2

现在让我们通过研究会合点问题 rendezvous problem来概括这一点。问题如下：您有两个线程，每个线程即将进入代码中的会合点。 任何一方都不应在另一方进入之前退出代码的这一部分。考虑为此任务使用两个信号量，详情请参阅 rendezvous.c。

 rendezvous.c:

```c
#include <stdio.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
// If done correctly, each child should print their "before" message
// before either prints their "after" message. Test by adding sleep(1)
// calls in various locations.

sem_t *s1, *s2;

void *child_1(void *arg) {
    printf("child 1: before\n");
    // what goes here?
    printf("child 1: after\n");
    return NULL;
}

void *child_2(void *arg) {
    printf("child 2: before\n");
    // what goes here?
    printf("child 2: after\n");
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    printf("parent: begin\n");
    // init semaphores here
    pthread_create(&p1, NULL, child_1, NULL);
    pthread_create(&p2, NULL, child_2, NULL);
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf("parent: end\n");
    return 0;
}
```

目前运行结果：

<img src="截屏2024-06-03 下午9.34.25.png" alt="截屏2024-06-03 下午9.34.25" style="zoom:67%;" />

如果操作正确，每个child都应该在打印各自的“after”之前打印各自的“before”。

最终修改的代码如下：

```c
#include <stdio.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
// If done correctly, each child should print their "before" message
// before either prints their "after" message. Test by adding sleep(1)
// calls in various locations.

sem_t *s1, *s2;

void *child_1(void *arg) {
    printf("child 1: before\n");
    // what goes here?
    sleep(1);
    sem_post(s1);
    sem_wait(s2);
    printf("child 1: after\n");
    return NULL;
}

void *child_2(void *arg) {
    printf("child 2: before\n");
    // what goes here?
    sleep(1);
    sem_post(s2);
    sem_wait(s1);
    printf("child 2: after\n");
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    printf("parent: begin\n");
    // init semaphores here
 	  sem_unlink("s1");
    sem_unlink("s2");
    s1 = sem_open("s1", O_CREAT | O_EXCL, NULL, 0);
    s2 = sem_open("s2", O_CREAT | O_EXCL, NULL, 0);
    pthread_create(&p1, NULL, child_1, NULL);
    pthread_create(&p2, NULL, child_2, NULL);
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf("parent: end\n");
    return 0;
}
```

运行结果：

<img src="截屏2024-06-03 下午9.33.41.png" alt="截屏2024-06-03 下午9.33.41" style="zoom:67%;" />

## Q3

现在让我们解决 reader-writer问题，也如文本中所述。在第一次运行中，不用担心饥饿。有关详细信息，请参阅reader-writer.c中的代码。在您的代码中添加sleep()调用，以证明它按您预期工作。你能证明饥饿问题的存在吗？

首先阅读reader-writer.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"

//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
} rwlock_t;


void rwlock_init(rwlock_t *rw) {
}

void rwlock_acquire_readlock(rwlock_t *rw) {
}

void rwlock_release_readlock(rwlock_t *rw) {
}

void rwlock_acquire_writelock(rwlock_t *rw) {
}

void rwlock_release_writelock(rwlock_t *rw) {
}

//
// Don't change the code below (just use it!)
// 

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
	rwlock_acquire_readlock(&lock);
	printf("read %d\n", value);
	rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
	rwlock_acquire_writelock(&lock);
	value++;
	printf("write %d\n", value);
	rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);			//运行的第二个参数
    int num_writers = atoi(argv[2]);			//运行的第三个参数
    loops = atoi(argv[3]);								//运行的第四个参数

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
  //创建读者线程
    for (i = 0; i < num_readers; i++)
	Pthread_create(&pr[i], NULL, reader, NULL);
  
  //创建写者线程
    for (i = 0; i < num_writers; i++)
	Pthread_create(&pw[i], NULL, writer, NULL);

  //等待所有读者运行结束
    for (i = 0; i < num_readers; i++)
	Pthread_join(pr[i], NULL);
  
 	//等待所有写者运行结束
    for (i = 0; i < num_writers; i++)
	Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}
```

可以看到reader-writer.c的main函数要求输入4个参数，其中第一个参数是./reader-writer，第2～第4个参数分别是读者的数量、写者的数量以及读写的次数。

不修改代码运行可发现写者在读者读取value时改变value，导致读者读取了错误value：

<img src="截屏2024-06-03 下午10.21.32.png" alt="截屏2024-06-03 下午10.21.32" style="zoom:67%;" />

本题需要我们完善代码，补充结构体和实现读写锁的初始化、读锁的获取释放、写锁的获取释放。

1. 结构体中应包含读锁和写锁以及读者的数量

2. rwlock_init函数用于初始化读写锁：

   - 将读者的数量初始化为0；

   - 初始化读锁和写锁，注意这里要将信号量的初始值设置为1，用作锁，第一个调用sem_wait的线程就不会进入睡眠，之后调用的线程就会睡眠等待被唤醒

3.  rwlock_acquire_readlock函数实现读者获取锁

   - 首先读者获取原锁，保证接下来的操作的原子性
   - 第一个获取读锁的读者也要获取写锁，保证在有读者运行的时候写者不能改写value
   - 最后读者释放原锁，让其他的读者也能获取读锁，实现多个读者能同时读取value

4. rwlock_release_readlock函数实现读者释放读锁

   - 首先读者获取原锁，保证接下来的操作的原子性
   - 最后一个读者释放写锁，此时没有读者在运行，写者可以获得写锁改写value
   - 最后读者释放原锁

5. rwlock_acquire_writelock函数实现写者获取写锁

6. rwlock_release_writelock函数实现写者释放写锁

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
#include <fcntl.h>
#include <string.h>
//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
    sem_t* lock;        			//原锁
    sem_t* write_lock;       //写锁
    int reads;              //获取读锁的读者数量
} rwlock_t;


void rwlock_init(rwlock_t *rw) {
    rw->reads = 0;
    
    //在初始化锁时，先删除已存在的信号量，然后再创建新的信号量。
    sem_unlink("rwlock_read");
    sem_unlink("rwlock_write");
    
    //初始化读锁和写锁，初始值设为1是将信号量当作锁来使用
    rw->lock = sem_open("rwlock_read", O_CREAT | O_EXCL,  S_IRUSR | S_IWUSR, 1);
    if (rw->lock == SEM_FAILED) {
            perror("sem_open failed for read lock");
            sem_unlink("rwlock_read"); // 清理锁
            exit(1);
        }
    rw->write_lock = sem_open("rwlock_write", O_CREAT | O_EXCL,  S_IRUSR | S_IWUSR, 1);
    if (rw->write_lock == SEM_FAILED) {
           perror("sem_open failed for write lock");
           sem_unlink("rwlock_write"); // 清理锁
           exit(1);
       }
}

void rwlock_acquire_readlock(rwlock_t *rw) {
    sem_wait(rw->lock);
    rw->reads++;
    if (rw->reads == 1)                     //第一个读者获得写锁
        sem_wait(rw->write_lock);
    sem_post(rw->lock);             		   //一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。
}

void rwlock_release_readlock(rwlock_t *rw) {
    sem_wait(rw->lock);
    rw->reads--;
    if (rw->reads == 0)                     //最后一个读者释放写锁
    {
        sleep(1);
        sem_post(rw->write_lock);
    }
    sem_post(rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw) {
    sem_wait(rw->write_lock);
}

void rwlock_release_writelock(rwlock_t *rw) {
    sleep(1);
    sem_post(rw->write_lock);
}

//
// Don't change the code below (just use it!)
//

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_readlock(&lock);
        printf("read %d\n", value);
        rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_writelock(&lock);
        value++;
        printf("write %d\n", value);
        rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);
    int num_writers = atoi(argv[2]);
    loops = atoi(argv[3]);

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
    for (i = 0; i < num_readers; i++)
    Pthread_create(&pr[i], NULL, reader, NULL);
    for (i = 0; i < num_writers; i++)
    Pthread_create(&pw[i], NULL, writer, NULL);

    for (i = 0; i < num_readers; i++)
    Pthread_join(pr[i], NULL);
    for (i = 0; i < num_writers; i++)
    Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}

```

运行结果：

可以看到读者都正确读取了value，且代码让读者和写者释放写锁前都睡眠了1秒，运行过程可以观察到最后一个读者读取完后确实会睡眠1秒，写者写完后也会睡眠1秒。另外可以观察到又一段时间一直都是读者获取锁在读取数据，造成了写者饥饿。

<img src="截屏2024-06-04 下午3.59.46.png" alt="截屏2024-06-04 下午3.59.46" style="zoom:67%;" />

## Q4

让我们再看看read_writer的问题，但这次，担心饥饿。你如何确保所有读者和写者运行？有关详细信息，请参阅reader-writer-nostarve.c。

reader-writer-nostarve.c:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"

//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
} rwlock_t;


void rwlock_init(rwlock_t *rw) {
}

void rwlock_acquire_readlock(rwlock_t *rw) {
}

void rwlock_release_readlock(rwlock_t *rw) {
}

void rwlock_acquire_writelock(rwlock_t *rw) {
}

void rwlock_release_writelock(rwlock_t *rw) {
}

//
// Don't change the code below (just use it!)
// 

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_readlock(&lock);
        printf("read %d\n", value);
        rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_writelock(&lock);
        value++;
        printf("write %d\n", value);
        rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);
    int num_writers = atoi(argv[2]);
    loops = atoi(argv[3]);

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
    for (i = 0; i < num_readers; i++)
	Pthread_create(&pr[i], NULL, reader, NULL);
    for (i = 0; i < num_writers; i++)
	Pthread_create(&pw[i], NULL, writer, NULL);

    for (i = 0; i < num_readers; i++)
	Pthread_join(pr[i], NULL);
    for (i = 0; i < num_writers; i++)
	Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}
```

上一题中我们实现了读写锁，但该锁有一些缺陷，尤其是公平性。读者很容易饿死写者，要让读者不饿死写者，应该在有写者等待时，避

免更多的读者进入并持有锁。

改进后的代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "common_threads.h"
#include <semaphore.h>
#include <string.h>
//
// Your code goes in the structure and functions below
//

typedef struct __rwlock_t {
    sem_t* lock;                //原锁
    sem_t* write_lock;          //写锁
    sem_t* writer_waiting;      //写者在等待的信号量
    int reads;                  //获取读锁的读者数量
} rwlock_t;


void rwlock_init(rwlock_t *rw) {
    rw->reads = 0;
    
    //在初始化锁时，先删除已存在的信号量，然后再创建新的信号量。
    sem_unlink("rwlock_read");
    sem_unlink("rwlock_write");
    sem_unlink("writer_wait_lock");
    
    //初始化读锁和写锁，初始值设为1是将信号量当作锁来使用
    rw->lock = sem_open("rwlock_read", O_CREAT | O_EXCL,  S_IRUSR | S_IWUSR, 1);
    if (rw->lock == SEM_FAILED) {
            perror("sem_open failed for read lock");
            sem_unlink("rwlock_read"); // 清理锁
            exit(1);
        }
    
    rw->write_lock = sem_open("rwlock_write", O_CREAT | O_EXCL,  S_IRUSR | S_IWUSR, 1);
    if (rw->write_lock == SEM_FAILED) {
           perror("sem_open failed for write lock");
           sem_unlink("rwlock_write"); // 清理锁
           exit(1);
       }
    
    rw->writer_waiting = sem_open("writer_wait_lock", O_CREAT | O_EXCL,  S_IRUSR | S_IWUSR, 1);
    if (rw->write_lock == SEM_FAILED) {
           perror("sem_open failed for writer_wait_lock");
           sem_unlink("writer_wait_lock"); // 清理锁
           exit(1);
       }
}

void rwlock_acquire_readlock(rwlock_t *rw) {
    sem_wait(rw->writer_waiting);
    sem_wait(rw->lock);
    rw->reads++;
    if (rw->reads == 1)                     //第一个读者获得写锁
        sem_wait(rw->write_lock);
    sem_post(rw->lock);                //一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。
    sem_post(rw->writer_waiting);
}

void rwlock_release_readlock(rwlock_t *rw) {
    sem_wait(rw->lock);
    rw->reads--;
    if (rw->reads == 0)                     //最后一个读者释放写锁
    {
        sleep(1);
        sem_post(rw->write_lock);
    }
    sem_post(rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw) {
    sem_wait(rw->writer_waiting);
    sem_wait(rw->write_lock);
    sem_post(rw->writer_waiting);
}

void rwlock_release_writelock(rwlock_t *rw) {
    sem_post(rw->write_lock);
}

//
// Don't change the code below (just use it!)
// 

int loops;
int value = 0;

rwlock_t lock;

void *reader(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_readlock(&lock);
        printf("read %d\n", value);
        rwlock_release_readlock(&lock);
    }
    return NULL;
}

void *writer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        rwlock_acquire_writelock(&lock);
        value++;
        printf("write %d\n", value);
        rwlock_release_writelock(&lock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 4);
    int num_readers = atoi(argv[1]);
    int num_writers = atoi(argv[2]);
    loops = atoi(argv[3]);

    pthread_t pr[num_readers], pw[num_writers];

    rwlock_init(&lock);

    printf("begin\n");

    int i;
    for (i = 0; i < num_readers; i++)
	Pthread_create(&pr[i], NULL, reader, NULL);
    for (i = 0; i < num_writers; i++)
	Pthread_create(&pw[i], NULL, writer, NULL);

    for (i = 0; i < num_readers; i++)
	Pthread_join(pr[i], NULL);
    for (i = 0; i < num_writers; i++)
	Pthread_join(pw[i], NULL);

    printf("end: value %d\n", value);

    return 0;
}
```

思路是新增了一个锁writer_waiting，在等待的写者就会持有这个锁，这样在其他读者在试图获得读锁进入临界区时，如果有写者在等待，读者也会在获取锁时因为不能持有writer_waiting锁而进入睡眠，避免了在有写者等待时更多读者进入。

运行结果：

可以看到读者和写者都没有占用很久的CPU，没有线程被饿死。

<img src="截屏2024-06-04 下午4.50.46.png" alt="截屏2024-06-04 下午4.50.46" style="zoom:67%;" />

## Q5

使用信号量来构建一个no-starve的互斥锁，任何试图获取互斥锁的线程最终都会获得它。有关更多信息，请参阅mutex-nostarve.c中的代码。

mutex-nostarve.c：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include "common_threads.h"

//
// Here, you have to write (almost) ALL the code. Oh no!
// How can you show that a thread does not starve
// when attempting to acquire this mutex you build?
//

typedef __ns_mutex_t {
} ns_mutex_t;

void ns_mutex_init(ns_mutex_t *m) {
}

void ns_mutex_acquire(ns_mutex_t *m) {
}

void ns_mutex_release(ns_mutex_t *m) {
}


void *worker(void *arg) {
    return NULL;
}

int main(int argc, char *argv[]) {
    printf("parent: begin\n");
    printf("parent: end\n");
    return 0;
}
```

作业要求我们补充代码，构建一个no-starve的互斥锁

修改后的代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include "common_threads.h"
#include <semaphore.h>
#include <string.h>
#include <fcntl.h>
//
// Here, you have to write (almost) ALL the code. Oh no!
// How can you show that a thread does not starve
// when attempting to acquire this mutex you build?
//

typedef struct __ns_mutex_t {
    sem_t* barrier;
    sem_t* mutex;
    sem_t* wait;
    int wait_t;
    int barriers;
} ns_mutex_t;

typedef struct __tinfo_t {
    int thread_id;
} tinfo_t;

void ns_mutex_init(ns_mutex_t *m) {
    sem_unlink("mutex");
    sem_unlink("barrier");
    sem_unlink("wait");
    m->wait_t = 0;
    m->barriers = 0;
    
    m->barrier = sem_open("barrier", O_CREAT | O_EXCL, 0644, 1);
    if (m->barrier == SEM_FAILED) {
        perror("sem_open failed for barrier");
        sem_unlink("barrier");
        exit(1);
    }
    
    m->mutex = sem_open("mutex", O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, 0);
    if (m->mutex == SEM_FAILED) {
        perror("sem_open failed for mutex");
        sem_unlink("mutex");
        exit(1);
    }
    

    m->wait = sem_open("wait", O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, 1);
    if (m->wait == SEM_FAILED) {
        perror("sem_open failed for wait");
        sem_unlink("wait");
        exit(1);
    }
}

void ns_mutex_acquire(ns_mutex_t *m) {
    sem_wait(m->wait);
    m->wait_t++;
    sem_post(m->wait);
    
    sem_wait(m->barrier);
    m->barriers++;
    sem_wait(m->wait);
    m->wait_t--;
    
    if (m->wait_t)
    {
        sem_post(m->wait);
        sem_post(m->barrier);
    }
    else
    {
        sem_post(m->wait);
        sem_post(m->mutex);
    }
    
    sem_wait(m->mutex);
    m->barriers--;
}

void ns_mutex_release(ns_mutex_t *m) {
    if (m->barriers)
        sem_post(m->mutex);
    else
        sem_post(m->barrier);
}

ns_mutex_t mlock;
int loops;

void *worker(void *arg) {
    tinfo_t *t = (tinfo_t *) arg;
    int i;
    for (i = 0; i < loops; i++)
    {
        printf("worker %d try to get lock\n", t->thread_id);
        ns_mutex_acquire(&mlock);
        printf("worker %d: before\n", t->thread_id);
        printf("worker %d: after\n", t->thread_id);
        ns_mutex_release(&mlock);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    assert(argc == 3);
    int num_threads = atoi(argv[1]);
    loops = atoi(argv[2]);
    assert(num_threads > 0);

    pthread_t p[num_threads];
    tinfo_t t[num_threads];

    printf("parent: begin\n");
    ns_mutex_init(&mlock);
    
    int i;
    for (i = 0; i < num_threads; i++) {
        t[i].thread_id = i;
        pthread_create(&p[i], NULL, worker, &t[i]);
    }

    for (i = 0; i < num_threads; i++)
        pthread_join(p[i], NULL);
    
    printf("parent: end\n");
    return 0;
}
```

运行结果：

可以看到试图获取锁的线程都发出请求的顺序获得了锁，保证了竞争的公平性。

<img src="截屏2024-06-05 上午11.32.38.png" alt="截屏2024-06-05 上午11.32.38" style="zoom:67%;" />