# 第30章（1，2，4，8-11）

## Q1

我们的第一个问题关注main-two-cvs-while.c（工作解决方案）。首先，研究代码。你认为你了解运行程序时应该发生什么吗？

```c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <pthread.h>
#include <sys/time.h>
#include <string.h>

#include "common.h"
#include "common_threads.h"

#include "pc-header.h"

// used in producer/consumer signaling protocol
pthread_cond_t empty  = PTHREAD_COND_INITIALIZER;
pthread_cond_t fill   = PTHREAD_COND_INITIALIZER;
pthread_mutex_t m     = PTHREAD_MUTEX_INITIALIZER;

#include "main-header.h"

void do_fill(int value) {
    // ensure empty before usage
    ensure(buffer[fill_ptr] == EMPTY, "error: tried to fill a non-empty buffer");
    buffer[fill_ptr] = value;
    fill_ptr = (fill_ptr + 1) % max;
    num_full++;
}

int do_get() {
    int tmp = buffer[use_ptr];
    ensure(tmp != EMPTY, "error: tried to get an empty buffer");
    buffer[use_ptr] = EMPTY; 
    use_ptr = (use_ptr + 1) % max;
    num_full--;
    return tmp;
}

void *producer(void *arg) {
    int id = (int) arg;
    // make sure each producer produces unique values
    int base = id * loops; 
    int i;
    for (i = 0; i < loops; i++) {   p0;
	Mutex_lock(&m);             p1;
	while (num_full == max) {   p2;
	    Cond_wait(&empty, &m);  p3;
	}
	do_fill(base + i);          p4;
	Cond_signal(&fill);         p5;
	Mutex_unlock(&m);           p6;
    }
    return NULL;
}
                                                                               
void *consumer(void *arg) {
    int id = (int) arg;
    int tmp = 0;
    int consumed_count = 0;
    while (tmp != END_OF_STREAM) { c0;
	Mutex_lock(&m);            c1;
	while (num_full == 0) {    c2;
	    Cond_wait(&fill, &m);  c3;
        }
	tmp = do_get();            c4;
	Cond_signal(&empty);       c5;
	Mutex_unlock(&m);          c6;
	consumed_count++;
    }

    // return consumer_count-1 because END_OF_STREAM does not count
    return (void *) (long long) (consumed_count - 1);
}

// must set these appropriately to use "main-common.c"
pthread_cond_t *fill_cv = &fill;
pthread_cond_t *empty_cv = &empty;

// all codes use this common base to start producers/consumers
// and all the other related stuff
#include "main-common.c"
```

main-two-cvs-while.c中使用了两个条件变量empty和fill，以及一个互斥锁m保证生产者和消费者之间不会出现竞态条件，程序运行时，如果是生产者执行，它会先获得锁，再检查缓冲区是否已满，未满则向缓冲区填入数据，已满则进入睡眠并释放锁，等待消费者的信号再唤醒获得锁。如果是消费者执行，它会先获得锁，再检查缓冲区是否为空，为空则则进入睡眠并释放锁，等待消费者的信号再唤醒获得锁，否则从缓冲区取出数据消费。使用两个条件变量可以很好避免死锁，并确保有界缓冲区同时只有一个线程访问。

## Q2

让一个生产者和一个消费者一起运行，并让生产者产生一些变量。从缓冲区（大小为1）开始，然后增加它。代码的行为如何随着更大的缓冲区而变化？（或者它是否变化？）当您将消费者睡眠字符串从默认（无睡眠）更改为-C 0,0,0,0,0,0,1时，并用不同缓冲区大小（例如-m 10）和不同数量的生成项（例如-l 100），预测num_full是什么。

让缓冲区大小从1开始变化：

```sh
./main-two-cvs-while -l 3 -m 1 -p 1 -c 1 -v
./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v
./main-two-cvs-while -l 3 -m 3 -p 1 -c 1 -v
./main-two-cvs-while -l 3 -m 4 -p 1 -c 1 -v
```

对比发现代码的行为没有变化，都是在生产者生产完3个变量，消费者消费完3个变量后，生产者最后生产一个特定变END_OF_STREAM，消费者再去消费时就会结束运行，最后生产者和消费者指针都指向缓冲区同一位置。

m = 1

<img src="截屏2024-06-02 上午11.59.32.png" alt="截屏2024-06-02 上午11.59.32" style="zoom: 67%;" />

m = 2

<img src="截屏2024-06-02 下午12.00.04.png" alt="截屏2024-06-02 下午12.00.04" style="zoom: 67%;" />

m = 3

<img src="截屏2024-06-02 下午12.00.27.png" alt="截屏2024-06-02 下午12.00.27" style="zoom: 67%;" />

m = 4

<img src="截屏2024-06-02 下午12.00.47.png" alt="截屏2024-06-02 下午12.00.47" style="zoom: 67%;" />

将消费者睡眠字符串从默认（无睡眠）更改为-C 0,0,0,0,0,0,1时，并用不同缓冲区大小（例如-m 10）和不同数量的生成项（例如-l 100）：

```sh
./main-two-cvs-while -l 100 -m 10 -p 1 -c 1 -C 0,0,0,0,0,0,1 -v
```

根据设置的参数，-C 0,0,0,0,0,0,1，是让消费者执行c6行操作（释放锁）前进入睡眠，于是程序会切换到生产者继续运行。

通过运行结果来看，第一次生产和消费后，消费者执行c6行前先睡眠了1秒后消费者才继续执行c6释放锁，并切换到生产者执行p1行，因为后续消费者一直没有睡眠，所以生产者执行完p5、p6行后不会唤醒消费者立即去执行消费者代码，系统一直没有调度，直到生产者将缓冲区填满后进入睡眠并释放锁，等到消费者发送信号量empty。<img src="截屏2024-06-02 上午11.31.52.png" alt="截屏2024-06-02 上午11.31.52" style="zoom: 67%;" />

后面的执行就是消费者和生产者正常交替执行，消费者每消费完一个变量就会唤醒生产者生产新的变量<img src="截屏2024-06-02 上午11.42.54.png" alt="截屏2024-06-02 上午11.42.54" style="zoom: 67%;" />

最后生产者生产完所有变量（包括END_OF_STREAM）后，一直是消费者进行消费，直到消费END_OF_STREAM退出。<img src="截屏2024-06-02 上午11.58.06.png" alt="截屏2024-06-02 上午11.58.06" style="zoom: 67%;" />

## Q3

让我们看看一些timings。对于一个生产者，三个消费者，一个大小为1的共享缓冲区，且每个消费者在c3点暂停一秒钟，您认为执行需要多长时间？ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t

### 最优情况：

每当消费者运行到c1时系统都发生中断并调度运行生产者向缓冲区生产变量，这样每个消费者都不会执行c2、c3行代码，不会进入睡眠，此时timings为0s

<img src="截屏2024-06-02 下午3.18.37.png" alt="截屏2024-06-02 下午3.18.37" style="zoom: 67%;" /><img src="截屏2024-06-02 下午3.19.13.png" alt="截屏2024-06-02 下午3.19.13" style="zoom: 67%;" /><img src="截屏2024-06-02 下午3.19.35.png" alt="截屏2024-06-02 下午3.19.35" style="zoom: 67%;" />

最优情况发生概率比较小，多次运行后能得到的最短timings是大约2s，可以看到代码运行过程中，有多次都是生产者先生产才到消费者执行c1行代码，消费者执行c3行代码次数较少

### 最差情况：

生产者都是在3个消费者执行c3代码进入睡眠后才生产变量，所以每消费一个变量前，3个消费者消费一共会睡眠3秒，这样要生产消费10个变量以及END_OF_STREAM，timings为33s





## Q4

现在让我们看看main-one-cv-while.c。对于一个生产者、一个消费者和大小为1的缓冲区，你可以配置睡眠字符串，以导致此代码出现问题吗？

main-one-cv-while.c只使用了一个信号量，而会出现问题是存在多个生产者和消费者，例如一个生产者和两个消费者，如果消费者c1、c2先运行，此时它们都没有数据可取，都进入睡眠，接下来生产者运行，它生产一次后并继续试图生产进入睡眠，此时唤醒c1消费者，c1消费完后要唤醒一个线程并进入睡眠，而此时如果唤醒的事c2，此时c2再检查缓冲区发现也没有数据可取，也进入睡眠，至此所有消费者和生产者都进入了睡眠。

而对于只有一个生产者、一个消费者的情况，生产者依然只能唤醒消费者，消费者也只能唤醒生产者，所以无论怎么配置睡眠字符串，都不会导致代码出现问题。

## Q5

现在将消费者数量改为两个。你能为生产者和消费者构建睡眠字符串，以便在代码中造成问题吗？

如果是一个生产者和两个消费者，如Q4中所述，要让代码出现问题，需要让消费者去唤醒消费者，但每次唤醒的线程是随机的，无法构建睡眠字符串让消费者固定唤醒另一个消费者，所以即使不构建代码也会出现问题。

<img src="截屏2024-06-02 下午4.10.21.png" alt="截屏2024-06-02 下午4.10.21" style="zoom:67%;" />图中运行结果就是不配置睡眠字符串，在最后可以看到c1消费完后唤醒的不是p0而是c0，导致最后三者都进入了睡眠，程序没有再运行下去。

## Q6

现在检查main-two-cvs-if.c。你能在这个代码中引起问题吗？再次考虑只有一个消费者的情况，然后考虑有不止一个消费者的情况

main-two-cvs-if.c中消费者和生产者判断缓冲区为空和已满都只判断一次，对于只有一个消费者和一个生产者的情况，代码不会产生问题，但如果不止一个消费者，以两个消费者和一个生产者为例，消费者c0先运行并进入睡眠后，生产者在缓冲区生产一个变量并唤醒消费者c0，但如果c0只是唤醒但并没有运行，而另一个消费者c1抢先执行，消费了缓冲区中的值（c1,c2,c4,c5,c6，跳过了 c3 的等待，因为缓冲区是非空的）。现在消费者c0运行，它重新获取锁并执行c4，但缓冲区已无法消费，代码出错。

<img src="截屏2024-06-02 下午4.45.36.png" alt="截屏2024-06-02 下午4.45.36" style="zoom:67%;" />

```
 NF        P0 C0 C1 
  0 [*--- ] p0
  0 [*--- ] p1
  1 [*  0 ] p4
  1 [*  0 ] p5
  1 [*  0 ] p6
  1 [*  0 ] p0
  1 [*  0 ] p1
  1 [*  0 ] p2
  1 [*  0 ]    c0
  1 [*  0 ]    c1
  0 [*--- ]    c4
  0 [*--- ]       c0
  0 [*--- ]    c5
  0 [*--- ]    c6
  0 [*--- ]    c0
  0 [*--- ]    c1
  0 [*--- ]    c2
  0 [*--- ] p3
  1 [*  1 ] p4
  1 [*  1 ] p5
  1 [*  1 ] p6
  1 [*  1 ] p0
  1 [*  1 ] p1
  1 [*  1 ] p2
  1 [*  1 ]       c1
  0 [*--- ]       c4
  0 [*--- ]       c5
  0 [*--- ]       c6
  0 [*--- ]       c0
  0 [*--- ]       c1
  0 [*--- ]       c2
  0 [*--- ] p3
  1 [*  2 ] p4
  1 [*  2 ] p5	
  1 [*  2 ] p6								<---- 生产者唤醒消费者c0
  1 [*  2 ]       c3					<---- 此时消费者c1抢先运行
  0 [*--- ]       c4					<---- 此时消费者c1消耗缓冲区
  0 [*--- ]       c5				
  0 [*--- ]       c6
  0 [*--- ]    c3							<---- 此时消费者c0才运行并重新获得锁返回
  0 [*--- ]       c0
error: tried to get an empty buffer		<---- 此时消费者c0在c4行do_get()出错
```



## Q7

最后，检查main-two-cvs-while-extra-unlock.c。当你在上锁或释放锁时，会出现什么问题？根据睡眠字符串，你能稳定地导致这样的问题发生吗？会发生什么坏事？

main-two-cvs-while-extra-unlock.c在生产者生产前和消费者消费前都释放了锁，之后才再次上锁，这导致二者对缓冲区的操作都不是原子操作，会导致多个生产者同时进入临界区，同时访问共享缓存区同一区域，产生并发问题。例如一个生产者将上一个生产者生产的数据覆盖，或是两个消费者一起消费同一区域的数据，导致其中一个消费者获取不到数据。

```c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <pthread.h>
#include <sys/time.h>
#include <string.h>

#include "common.h"
#include "common_threads.h"

#include "pc-header.h"

pthread_cond_t empty  = PTHREAD_COND_INITIALIZER;
pthread_cond_t fill   = PTHREAD_COND_INITIALIZER;
pthread_mutex_t m     = PTHREAD_MUTEX_INITIALIZER;

#include "main-header.h"

void do_fill(int value) {
    // ensure empty before usage
    ensure(buffer[fill_ptr] == EMPTY, "error: tried to fill a non-empty buffer");
    buffer[fill_ptr] = value;
    fill_ptr = (fill_ptr + 1) % max;
    num_full++;
}

int do_get() {
    int tmp = buffer[use_ptr];
    ensure(tmp != EMPTY, "error: tried to get an empty buffer");
    buffer[use_ptr] = EMPTY; 
    use_ptr = (use_ptr + 1) % max;
    num_full--;
    return tmp;
}

void *producer(void *arg) {
    int id = (int) arg;
    // make sure each producer produces unique values
    int base = id * loops; 
    int i;
    for (i = 0; i < loops; i++) {   p0;
	Mutex_lock(&m);             p1;
	while (num_full == max) {   p2;
	    Cond_wait(&empty, &m);  p3;
	}
	Mutex_unlock(&m);
	do_fill(base + i);          p4;
	Mutex_lock(&m);
	Cond_signal(&fill);         p5;
	Mutex_unlock(&m);           p6;
    }
    return NULL;
}
                                                                               
void *consumer(void *arg) {
    int id = (int) arg;
    int tmp = 0;
    int consumed_count = 0;
    while (tmp != END_OF_STREAM) { c0;
	Mutex_lock(&m);            c1;
	while (num_full == 0) {    c2;
	    Cond_wait(&fill, &m);  c3;
        }
	Mutex_unlock(&m);
	tmp = do_get();            c4;
	Mutex_lock(&m);
	Cond_signal(&empty);       c5;
	Mutex_unlock(&m);          c6;
	consumed_count++;
    }

    // return consumer_count-1 because END_OF_STREAM does not count
    return (void *) (long long) (consumed_count - 1);
}

// must set these appropriately to use "main-common.c"
pthread_cond_t *fill_cv = &fill;
pthread_cond_t *empty_cv = &empty;

// all codes use this common base to start producers/consumers
// and all the other related stuff
#include "main-common.c"
```

